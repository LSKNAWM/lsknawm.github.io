<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>abc</title>
      <link href="/2023/10/03/abcdefg/"/>
      <url>/2023/10/03/abcdefg/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Init 容器 - KubernetesInit 容器 - Kubernetes</title>
      <link href="/2023/10/03/init-rong-qi-kubernetesinit-rong-qi-kubernetes/"/>
      <url>/2023/10/03/init-rong-qi-kubernetesinit-rong-qi-kubernetes/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本文由 <a href="http://ksria.com/simpread/">简悦 SimpRead</a> 转码， 原文地址 <a href="https://kubernetes.io/zh-cn/docs/concepts/workloads/pods/init-containers/">kubernetes.io</a></p></blockquote><blockquote><p>本页提供了 Init 容器的概览。</p></blockquote><p>本页提供了 Init 容器的概览。Init 容器是一种特殊容器，在 <a href="https://kubernetes.io/zh-cn/docs/concepts/workloads/pods/">Pod</a> 内的应用容器启动之前运行。Init 容器可以包括一些应用镜像中不存在的实用工具和安装脚本。</p><p>你可以在 Pod 的规约中与用来描述应用容器的 <code>containers</code> 数组平行的位置指定 Init 容器。</p><h2 id="理解-Init-容器"><a href="#理解-Init-容器" class="headerlink" title="理解 Init 容器"></a>理解 Init 容器<a href="#understanding-init-containers"></a></h2><p>每个 <a href="https://kubernetes.io/zh-cn/docs/concepts/workloads/pods/">Pod</a> 中可以包含多个容器， 应用运行在这些容器里面，同时 Pod 也可以有一个或多个先于应用容器启动的 Init 容器。</p><p>Init 容器与普通的容器非常像，除了如下两点：</p><ul><li>它们总是运行到完成。</li><li>每个都必须在下一个启动之前成功完成。</li></ul><p>如果 Pod 的 Init 容器失败，kubelet 会不断地重启该 Init 容器直到该容器成功为止。 然而，如果 Pod 对应的 <code>restartPolicy</code> 值为 “Never”，并且 Pod 的 Init 容器失败， 则 Kubernetes 会将整个 Pod 状态设置为失败。</p><p>为 Pod 设置 Init 容器需要在 <a href="https://kubernetes.io/zh-cn/docs/reference/kubernetes-api/workload-resources/pod-v1/#PodSpec">Pod 规约</a>中添加 <code>initContainers</code> 字段， 该字段以 <a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.27/#container-v1-core">Container</a> 类型对象数组的形式组织，和应用的 <code>containers</code> 数组同级相邻。 参阅 API 参考的<a href="https://kubernetes.io/zh-cn/docs/reference/kubernetes-api/workload-resources/pod-v1/#Container">容器</a>章节了解详情。</p><p>Init 容器的状态在 <code>status.initContainerStatuses</code> 字段中以容器状态数组的格式返回 （类似 <code>status.containerStatuses</code> 字段）。</p><h3 id="与普通容器的不同之处"><a href="#与普通容器的不同之处" class="headerlink" title="与普通容器的不同之处"></a>与普通容器的不同之处<a href="#differences-from-regular-containers"></a></h3><p>Init 容器支持应用容器的全部字段和特性，包括资源限制、 <a href="https://kubernetes.io/zh-cn/docs/concepts/storage/volumes/">数据卷</a>和安全设置。 然而，Init 容器对资源请求和限制的处理稍有不同，在下面<a href="#resources">资源</a>节有说明。</p><p>同时 Init 容器不支持 <code>lifecycle</code>、<code>livenessProbe</code>、<code>readinessProbe</code> 和 <code>startupProbe</code>， 因为它们必须在 Pod 就绪之前运行完成。</p><p>如果为一个 Pod 指定了多个 Init 容器，这些容器会按顺序逐个运行。 每个 Init 容器必须运行成功，下一个才能够运行。当所有的 Init 容器运行完成时， Kubernetes 才会为 Pod 初始化应用容器并像平常一样运行。</p><h2 id="使用-Init-容器"><a href="#使用-Init-容器" class="headerlink" title="使用 Init 容器"></a>使用 Init 容器<a href="#using-init-containers"></a></h2><p>因为 Init 容器具有与应用容器分离的单独镜像，其启动相关代码具有如下优势：</p><ul><li><p>Init 容器可以包含一些安装过程中应用容器中不存在的实用工具或个性化代码。 例如，没有必要仅为了在安装过程中使用类似 <code>sed</code>、<code>awk</code>、<code>python</code> 或 <code>dig</code> 这样的工具而去 <code>FROM</code> 一个镜像来生成一个新的镜像。</p></li><li><p>应用镜像的创建者和部署者可以各自独立工作，而没有必要联合构建一个单独的应用镜像。</p></li><li><p>与同一 Pod 中的多个应用容器相比，Init 容器能以不同的文件系统视图运行。因此，Init 容器可以被赋予访问应用容器不能访问的 <a href="https://kubernetes.io/zh-cn/docs/concepts/configuration/secret/">Secret</a> 的权限。</p></li><li><p>由于 Init 容器必须在应用容器启动之前运行完成，因此 Init 容器提供了一种机制来阻塞或延迟应用容器的启动，直到满足了一组先决条件。 一旦前置条件满足，Pod 内的所有的应用容器会并行启动。</p></li><li><p>Init 容器可以安全地运行实用程序或自定义代码，而在其他方式下运行这些实用程序或自定义代码可能会降低应用容器镜像的安全性。 通过将不必要的工具分开，你可以限制应用容器镜像的被攻击范围。</p></li></ul><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例<a href="#examples"></a></h3><p>下面是一些如何使用 Init 容器的想法：</p><ul><li><p>等待一个 Service 完成创建，通过类似如下 Shell 命令：</p><pre class="line-numbers language-none"><code class="language-none">for i in {1..100}; do sleep 1; if nslookup myservice; then exit 0; fi; done; exit 1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>注册这个 Pod 到远程服务器，通过在命令中调用 API，类似如下：</p><pre class="line-numbers language-none"><code class="language-none">curl -X POST http://$MANAGEMENT_SERVICE_HOST:$MANAGEMENT_SERVICE_PORT/register -d 'instance=$(&lt;POD_NAME&gt;)&amp;ip=$(&lt;POD_IP&gt;)'<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>在启动应用容器之前等一段时间，使用类似命令：</p></li><li><p>克隆 Git 仓库到<a href="https://kubernetes.io/zh-cn/docs/concepts/storage/volumes/">卷</a>中。</p></li><li><p>将配置值放到配置文件中，运行模板工具为主应用容器动态地生成配置文件。 例如，在配置文件中存放 <code>POD_IP</code> 值，并使用 Jinja 生成主应用配置文件。</p></li></ul><h3 id="使用-Init-容器的情况"><a href="#使用-Init-容器的情况" class="headerlink" title="使用 Init 容器的情况"></a>使用 Init 容器的情况<a href="#init-containers-in-use"></a></h3><p>下面的例子定义了一个具有 2 个 Init 容器的简单 Pod。 第一个等待 <code>myservice</code> 启动， 第二个等待 <code>mydb</code> 启动。 一旦这两个 Init 容器都启动完成，Pod 将启动 <code>spec</code> 节中的应用容器。</p><pre class="line-numbers language-none"><code class="language-none">apiVersion: v1kind: Podmetadata:  name: myapp-pod  labels:    app.kubernetes.io/name: MyAppspec:  containers:  - name: myapp-container    image: busybox:1.28    command: ['sh', '-c', 'echo The app is running! &amp;&amp; sleep 3600']  initContainers:  - name: init-myservice    image: busybox:1.28    command: ['sh', '-c', "until nslookup myservice.$(cat /var/run/secrets/kubernetes.io/serviceaccount/namespace).svc.cluster.local; do echo waiting for myservice; sleep 2; done"]  - name: init-mydb    image: busybox:1.28    command: ['sh', '-c', "until nslookup mydb.$(cat /var/run/secrets/kubernetes.io/serviceaccount/namespace).svc.cluster.local; do echo waiting for mydb; sleep 2; done"]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>你通过运行下面的命令启动 Pod：</p><pre class="line-numbers language-none"><code class="language-none">kubectl apply -f myapp.yaml<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>输出类似于：</p><pre class="line-numbers language-none"><code class="language-none">pod/myapp-pod created<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>使用下面的命令检查其状态：</p><pre class="line-numbers language-none"><code class="language-none">kubectl get -f myapp.yaml<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>输出类似于：</p><pre class="line-numbers language-none"><code class="language-none">NAME        READY     STATUS     RESTARTS   AGEmyapp-pod   0/1       Init:0/2   0          6m<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>或者查看更多详细信息：</p><pre class="line-numbers language-none"><code class="language-none">kubectl describe -f myapp.yaml<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>输出类似于：</p><pre class="line-numbers language-none"><code class="language-none">Name:          myapp-podNamespace:     default[...]Labels:        app.kubernetes.io/name=MyAppStatus:        Pending[...]Init Containers:  init-myservice:[...]    State:         Running[...]  init-mydb:[...]    State:         Waiting      Reason:      PodInitializing    Ready:         False[...]Containers:  myapp-container:[...]    State:         Waiting      Reason:      PodInitializing    Ready:         False[...]Events:  FirstSeen    LastSeen    Count    From                      SubObjectPath                           Type          Reason        Message  ---------    --------    -----    ----                      -------------                           --------      ------        -------  16s          16s         1        {default-scheduler }                                              Normal        Scheduled     Successfully assigned myapp-pod to 172.17.4.201  16s          16s         1        {kubelet 172.17.4.201}    spec.initContainers{init-myservice}     Normal        Pulling       pulling image "busybox"  13s          13s         1        {kubelet 172.17.4.201}    spec.initContainers{init-myservice}     Normal        Pulled        Successfully pulled image "busybox"  13s          13s         1        {kubelet 172.17.4.201}    spec.initContainers{init-myservice}     Normal        Created       Created container init-myservice  13s          13s         1        {kubelet 172.17.4.201}    spec.initContainers{init-myservice}     Normal        Started       Started container init-myservice<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如需查看 Pod 内 Init 容器的日志，请执行：</p><pre class="line-numbers language-none"><code class="language-none">kubectl logs myapp-pod -c init-myservice # 查看第一个 Init 容器kubectl logs myapp-pod -c init-mydb      # 查看第二个 Init 容器<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>在这一刻，Init 容器将会等待至发现名称为 <code>mydb</code> 和 <code>myservice</code> 的<a href="https://kubernetes.io/zh-cn/docs/concepts/services-networking/service/">服务</a>。</p><p>如下为创建这些 Service 的配置文件：</p><pre class="line-numbers language-none"><code class="language-none">---apiVersion: v1kind: Servicemetadata:  name: myservicespec:  ports:  - protocol: TCP    port: 80    targetPort: 9376---apiVersion: v1kind: Servicemetadata:  name: mydbspec:  ports:  - protocol: TCP    port: 80    targetPort: 9377<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>创建 <code>mydb</code> 和 <code>myservice</code> 服务的命令：</p><pre class="line-numbers language-none"><code class="language-none">kubectl apply -f services.yaml<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>输出类似于：</p><pre class="line-numbers language-none"><code class="language-none">service/myservice createdservice/mydb created<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>这样你将能看到这些 Init 容器执行完毕，随后 <code>my-app</code> 的 Pod 进入 <code>Running</code> 状态：</p><pre class="line-numbers language-none"><code class="language-none">kubectl get -f myapp.yaml<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>输出类似于：</p><pre class="line-numbers language-none"><code class="language-none">NAME        READY     STATUS    RESTARTS   AGEmyapp-pod   1/1       Running   0          9m<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>这个简单例子应该能为你创建自己的 Init 容器提供一些启发。 <a href="#what-s-next">接下来</a>节提供了更详细例子的链接。</p><h2 id="具体行为"><a href="#具体行为" class="headerlink" title="具体行为"></a>具体行为<a href="#detailed-behavior"></a></h2><p>在 Pod 启动过程中，每个 Init 容器会在网络和数据卷初始化之后按顺序启动。 kubelet 运行依据 Init 容器在 Pod 规约中的出现顺序依次运行之。</p><p>每个 Init 容器成功退出后才会启动下一个 Init 容器。 如果某容器因为容器运行时的原因无法启动，或以错误状态退出，kubelet 会根据 Pod 的 <code>restartPolicy</code> 策略进行重试。 然而，如果 Pod 的 <code>restartPolicy</code> 设置为 “Always”，Init 容器失败时会使用 <code>restartPolicy</code> 的 “OnFailure” 策略。</p><p>在所有的 Init 容器没有成功之前，Pod 将不会变成 <code>Ready</code> 状态。 Init 容器的端口将不会在 Service 中进行聚集。正在初始化中的 Pod 处于 <code>Pending</code> 状态， 但会将状况 <code>Initializing</code> 设置为 false。</p><p>如果 Pod <a href="#pod-restart-reasons">重启</a>，所有 Init 容器必须重新执行。</p><p>对 Init 容器规约的修改仅限于容器的 <code>image</code> 字段。 更改 Init 容器的 <code>image</code> 字段，等同于重启该 Pod。</p><p>因为 Init 容器可能会被重启、重试或者重新执行，所以 Init 容器的代码应该是幂等的。 特别地，基于 <code>emptyDirs</code> 写文件的代码，应该对输出文件可能已经存在做好准备。</p><p>Init 容器具有应用容器的所有字段。然而 Kubernetes 禁止使用 <code>readinessProbe</code>， 因为 Init 容器不能定义不同于完成态（Completion）的就绪态（Readiness）。 Kubernetes 会在校验时强制执行此检查。</p><p>在 Pod 上使用 <code>activeDeadlineSeconds</code> 和在容器上使用 <code>livenessProbe</code> 可以避免 Init 容器一直重复失败。 <code>activeDeadlineSeconds</code> 时间包含了 Init 容器启动的时间。 但建议仅在团队将其应用程序部署为 Job 时才使用 <code>activeDeadlineSeconds</code>， 因为 <code>activeDeadlineSeconds</code> 在 Init 容器结束后仍有效果。 如果你设置了 <code>activeDeadlineSeconds</code>，已经在正常运行的 Pod 会被杀死。</p><p>在 Pod 中的每个应用容器和 Init 容器的名称必须唯一； 与任何其它容器共享同一个名称，会在校验时抛出错误。</p><h3 id="资源"><a href="#资源" class="headerlink" title="资源"></a>资源<a href="#resources"></a></h3><p>在给定的 Init 容器执行顺序下，资源使用适用于如下规则：</p><ul><li>所有 Init 容器上定义的任何特定资源的 limit 或 request 的最大值，作为 Pod <strong>有效初始 request/limit</strong>。 如果任何资源没有指定资源限制，这被视为最高限制。</li><li>Pod 对资源的 <strong>有效 limit/request</strong> 是如下两者中的较大者：<ul><li>所有应用容器对某个资源的 limit/request 之和</li><li>对某个资源的有效初始 limit/request</li></ul></li><li>基于有效 limit/request 完成调度，这意味着 Init 容器能够为初始化过程预留资源， 这些资源在 Pod 生命周期过程中并没有被使用。</li><li>Pod 的 <strong>有效 QoS 层</strong>，与 Init 容器和应用容器的一样。</li></ul><p>配额和限制适用于有效 Pod 的请求和限制值。 Pod 级别的 cgroups 是基于有效 Pod 的请求和限制值，和调度器相同。</p><h3 id="Pod-重启的原因"><a href="#Pod-重启的原因" class="headerlink" title="Pod 重启的原因"></a>Pod 重启的原因<a href="#pod-restart-reasons"></a></h3><p>Pod 重启会导致 Init 容器重新执行，主要有如下几个原因：</p><ul><li><p>Pod 的基础设施容器 (译者注：如 <code>pause</code> 容器) 被重启。这种情况不多见， 必须由具备 root 权限访问节点的人员来完成。</p></li><li><p>当 <code>restartPolicy</code> 设置为 <code>Always</code>，Pod 中所有容器会终止而强制重启。 由于<a href="https://kubernetes.io/zh-cn/docs/concepts/architecture/garbage-collection/">垃圾回收</a>机制的原因， Init 容器的完成记录将会丢失。</p></li></ul><p>当 Init 容器的镜像发生改变或者 Init 容器的完成记录因为垃圾收集等原因被丢失时， Pod 不会被重启。这一行为适用于 Kubernetes v1.20 及更新版本。 如果你在使用较早版本的 Kubernetes，可查阅你所使用的版本对应的文档。</p><h2 id="接下来"><a href="#接下来" class="headerlink" title="接下来"></a>接下来<a href="#%E6%8E%A5%E4%B8%8B%E6%9D%A5"></a></h2><ul><li>阅读<a href="https://kubernetes.io/zh-cn/docs/tasks/configure-pod-container/configure-pod-initialization/#create-a-pod-that-has-an-init-container">创建包含 Init 容器的 Pod</a></li><li>学习如何<a href="https://kubernetes.io/zh-cn/docs/tasks/debug/debug-application/debug-init-containers/">调试 Init 容器</a></li><li>阅读 <a href="https://kubernetes.io/zh-cn/docs/reference/command-line-tools-reference/kubelet/">kubelet</a> 和 <a href="https://kubernetes.io/zh-cn/docs/reference/kubectl/">kubectl</a> 的概述。</li><li>了解探针的<a href="https://kubernetes.io/zh-cn/docs/concepts/workloads/pods/pod-lifecycle/#types-of-probe">类型</a>： 存活态探针、就绪态探针、启动探针。</li></ul>]]></content>
      
      
      <categories>
          
          <category> kubernetes </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Pod - KubernetesPod - Kubernetes</title>
      <link href="/2023/10/03/pod-kubernetespod-kubernetes/"/>
      <url>/2023/10/03/pod-kubernetespod-kubernetes/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本文由 <a href="http://ksria.com/simpread/">简悦 SimpRead</a> 转码， 原文地址 <a href="https://kubernetes.io/zh-cn/docs/concepts/workloads/pods/#working-with-pods">kubernetes.io</a></p></blockquote><blockquote><p>Pod 是可以在 Kubernetes 中创建和管理的、最小的可部署的计算单元。</p></blockquote><p><strong>Information in this document may be out of date</strong></p><p>This document has an older update date than the original, so the information it contains may be out of date. If you’re able to read English, see the English version for the most up-to-date information: <a href="https://kubernetes.io/docs/concepts/workloads/pods/">Pods</a></p><p><strong>Pod</strong> 是可以在 Kubernetes 中创建和管理的、最小的可部署的计算单元。</p><p><strong>Pod</strong>（就像在鲸鱼荚或者豌豆荚中）是一组（一个或多个） <a href="https://kubernetes.io/zh-cn/docs/concepts/overview/what-is-kubernetes/#why-containers">容器</a>； 这些容器共享存储、网络、以及怎样运行这些容器的声明。 Pod 中的内容总是并置（colocated）的并且一同调度，在共享的上下文中运行。 Pod 所建模的是特定于应用的 “逻辑主机”，其中包含一个或多个应用容器， 这些容器相对紧密地耦合在一起。 在非云环境中，在相同的物理机或虚拟机上运行的应用类似于在同一逻辑主机上运行的云应用。</p><p>除了应用容器，Pod 还可以包含在 Pod 启动期间运行的 <a href="https://kubernetes.io/zh-cn/docs/concepts/workloads/pods/init-containers/">Init 容器</a>。 你也可以在集群支持<a href="https://kubernetes.io/zh-cn/docs/concepts/workloads/pods/ephemeral-containers/">临时性容器</a>的情况下， 为调试的目的注入临时性容器。</p><h2 id="什么是-Pod？"><a href="#什么是-Pod？" class="headerlink" title="什么是 Pod？"></a>什么是 Pod？<a href="#what-is-a-pod"></a></h2><p><strong>说明：</strong> 为了运行 Pod，你需要提前在每个节点安装好<a href="https://kubernetes.io/zh-cn/docs/setup/production-environment/container-runtimes/">容器运行时</a>。</p><p>Pod 的共享上下文包括一组 Linux 名字空间、控制组（cgroup）和可能一些其他的隔离方面， 即用来隔离<a href="https://kubernetes.io/zh-cn/docs/concepts/overview/what-is-kubernetes/#why-containers">容器</a>的技术。 在 Pod 的上下文中，每个独立的应用可能会进一步实施隔离。</p><p>Pod 类似于共享名字空间并共享文件系统卷的一组容器。</p><h2 id="使用-Pod"><a href="#使用-Pod" class="headerlink" title="使用 Pod"></a>使用 Pod<a href="#using-pods"></a></h2><p>下面是一个 Pod 示例，它由一个运行镜像 <code>nginx:1.14.2</code> 的容器组成。</p><pre class="line-numbers language-none"><code class="language-none">apiVersion: v1kind: Podmetadata:  name: nginxspec:  containers:  - name: nginx    image: nginx:1.14.2    ports:    - containerPort: 80<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>要创建上面显示的 Pod，请运行以下命令：</p><pre class="line-numbers language-none"><code class="language-none">kubectl apply -f https://k8s.io/examples/pods/simple-pod.yaml<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>Pod 通常不是直接创建的，而是使用工作负载资源创建的。 有关如何将 Pod 用于工作负载资源的更多信息，请参阅<a href="#working-with-pods">使用 Pod</a>。</p><h3 id="用于管理-pod-的工作负载资源"><a href="#用于管理-pod-的工作负载资源" class="headerlink" title="用于管理 pod 的工作负载资源"></a>用于管理 pod 的工作负载资源<a href="#workload-resources-for-managing-pods"></a></h3><p>通常你不需要直接创建 Pod，甚至单实例 Pod。 相反，你会使用诸如 <a href="https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/deployment/">Deployment</a> 或 <a href="https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/job/">Job</a> 这类工作负载资源来创建 Pod。 如果 Pod 需要跟踪状态，可以考虑 <a href="https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/statefulset/">StatefulSet</a> 资源。</p><p>Kubernetes 集群中的 Pod 主要有两种用法：</p><ul><li><p><strong>运行单个容器的 Pod</strong>。”每个 Pod 一个容器” 模型是最常见的 Kubernetes 用例； 在这种情况下，可以将 Pod 看作单个容器的包装器，并且 Kubernetes 直接管理 Pod，而不是容器。</p></li><li><p><strong>运行多个协同工作的容器的 Pod</strong>。 Pod 可能封装由多个紧密耦合且需要共享资源的共处容器组成的应用程序。 这些位于同一位置的容器可能形成单个内聚的服务单元 —— 一个容器将文件从共享卷提供给公众， 而另一个单独的 “边车”（sidecar）容器则刷新或更新这些文件。 Pod 将这些容器和存储资源打包为一个可管理的实体。</p><p><strong>说明：</strong></p><p>将多个并置、同管的容器组织到一个 Pod 中是一种相对高级的使用场景。 只有在一些场景中，容器之间紧密关联时你才应该使用这种模式。</p></li></ul><p>每个 Pod 都旨在运行给定应用程序的单个实例。如果希望横向扩展应用程序 （例如，运行多个实例以提供更多的资源），则应该使用多个 Pod，每个实例使用一个 Pod。 在 Kubernetes 中，这通常被称为<strong>副本（Replication）</strong>。 通常使用一种工作负载资源及其<a href="https://kubernetes.io/zh-cn/docs/concepts/architecture/controller/">控制器</a>来创建和管理一组 Pod 副本。</p><p>参见 <a href="#pods-and-controllers">Pod 和控制器</a>以了解 Kubernetes 如何使用工作负载资源及其控制器以实现应用的扩缩和自动修复。</p><h3 id="Pod-怎样管理多个容器"><a href="#Pod-怎样管理多个容器" class="headerlink" title="Pod 怎样管理多个容器"></a>Pod 怎样管理多个容器<a href="#how-pods-manage-multiple-containers"></a></h3><p>Pod 被设计成支持形成内聚服务单元的多个协作过程（形式为容器）。 Pod 中的容器被自动安排到集群中的同一物理机或虚拟机上，并可以一起进行调度。 容器之间可以共享资源和依赖、彼此通信、协调何时以及何种方式终止自身。</p><p>例如，你可能有一个容器，为共享卷中的文件提供 Web 服务器支持，以及一个单独的 “边车 (sidercar)” 容器负责从远端更新这些文件，如下图所示：</p><p><img src="https://d33wubrfki0l68.cloudfront.net/aecab1f649bc640ebef1f05581bfcc91a48038c4/728d6/images/docs/pod.svg"></p><p>有些 Pod 具有 <a href="https://kubernetes.io/zh-cn/docs/reference/glossary/?all=true#term-init-container">Init 容器</a>和 <a href="https://kubernetes.io/zh-cn/docs/reference/glossary/?all=true#term-app-container">应用容器</a>。 Init 容器会在启动应用容器之前运行并完成。</p><p>Pod 天生地为其成员容器提供了两种共享资源：<a href="#pod-networking">网络</a>和<a href="#pod-storage">存储</a>。</p><h2 id="使用-Pod-1"><a href="#使用-Pod-1" class="headerlink" title="使用 Pod"></a>使用 Pod<a href="#working-with-pods"></a></h2><p>你很少在 Kubernetes 中直接创建一个个的 Pod，甚至是单实例（Singleton）的 Pod。 这是因为 Pod 被设计成了相对临时性的、用后即抛的一次性实体。 当 Pod 由你或者间接地由<a href="https://kubernetes.io/zh-cn/docs/concepts/architecture/controller/">控制器</a> 创建时，它被调度在集群中的<a href="https://kubernetes.io/zh-cn/docs/concepts/architecture/nodes/">节点</a>上运行。 Pod 会保持在该节点上运行，直到 Pod 结束执行、Pod 对象被删除、Pod 因资源不足而被<strong>驱逐</strong>或者节点失效为止。</p><p><strong>说明：</strong> 重启 Pod 中的容器不应与重启 Pod 混淆。 Pod 不是进程，而是容器运行的环境。 在被删除之前，Pod 会一直存在。</p><p>Pod 的名称必须是一个合法的 <a href="https://kubernetes.io/zh-cn/docs/concepts/overview/working-with-objects/names#dns-subdomain-names">DNS 子域</a>值， 但这可能对 Pod 的主机名产生意外的结果。为获得最佳兼容性，名称应遵循更严格的 <a href="https://kubernetes.io/zh-cn/docs/concepts/overview/working-with-objects/names#dns-label-names">DNS 标签</a>规则。</p><h3 id="Pod-操作系统"><a href="#Pod-操作系统" class="headerlink" title="Pod 操作系统"></a>Pod 操作系统<a href="#pod-os"></a></h3><p><strong>特性状态：</strong> <code>Kubernetes v1.25 [stable]</code></p><p>你应该将 <code>.spec.os.name</code> 字段设置为 <code>windows</code> 或 <code>linux</code> 以表示你希望 Pod 运行在哪个操作系统之上。 这两个是 Kubernetes 目前支持的操作系统。将来，这个列表可能会被扩充。</p><p>在 Kubernetes v1.27 中，为此字段设置的值对 Pod 的<a href="https://kubernetes.io/zh-cn/docs/reference/command-line-tools-reference/kube-scheduler/">调度</a>没有影响。 设置 <code>. spec.os.name</code> 有助于确定性地标识 Pod 的操作系统并用于验证。 如果你指定的 Pod 操作系统与运行 kubelet 所在节点的操作系统不同， 那么 kubelet 将会拒绝运行该 Pod。 <a href="https://kubernetes.io/zh-cn/docs/concepts/security/pod-security-standards/">Pod 安全标准</a>也使用这个字段来避免强制执行与该操作系统无关的策略。</p><h3 id="Pod-和控制器"><a href="#Pod-和控制器" class="headerlink" title="Pod 和控制器"></a>Pod 和控制器<a href="#pods-and-controllers"></a></h3><p>你可以使用工作负载资源来创建和管理多个 Pod。 资源的控制器能够处理副本的管理、上线，并在 Pod 失效时提供自愈能力。 例如，如果一个节点失败，控制器注意到该节点上的 Pod 已经停止工作， 就可以创建替换性的 Pod。调度器会将替身 Pod 调度到一个健康的节点执行。</p><p>下面是一些管理一个或者多个 Pod 的工作负载资源的示例：</p><ul><li><a href="https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/deployment/">Deployment</a></li><li><a href="https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/statefulset/">StatefulSet</a></li><li><a href="https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/daemonset/">DaemonSet</a></li></ul><h3 id="Pod-模板"><a href="#Pod-模板" class="headerlink" title="Pod 模板"></a>Pod 模板<a href="#pod-templates"></a></h3><p><a href="https://kubernetes.io/zh-cn/docs/concepts/workloads/">工作负载</a>资源的控制器通常使用 <strong>Pod 模板（Pod Template）</strong> 来替你创建 Pod 并管理它们。</p><p>Pod 模板是包含在工作负载对象中的规范，用来创建 Pod。这类负载资源包括 <a href="https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/deployment/">Deployment</a>、 <a href="https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/job/">Job</a> 和 <a href="https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/daemonset/">DaemonSet</a> 等。</p><p>工作负载的控制器会使用负载对象中的 <code>PodTemplate</code> 来生成实际的 Pod。 <code>PodTemplate</code> 是你用来运行应用时指定的负载资源的目标状态的一部分。</p><p>下面的示例是一个简单的 Job 的清单，其中的 <code>template</code> 指示启动一个容器。 该 Pod 中的容器会打印一条消息之后暂停。</p><pre class="line-numbers language-none"><code class="language-none">apiVersion: batch/v1kind: Jobmetadata:  name: hellospec:  template:    # 这里是 Pod 模板    spec:      containers:      - name: hello        image: busybox:1.28        command: ['sh', '-c', 'echo "Hello, Kubernetes!" &amp;&amp; sleep 3600']      restartPolicy: OnFailure    # 以上为 Pod 模板<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>修改 Pod 模板或者切换到新的 Pod 模板都不会对已经存在的 Pod 直接起作用。 如果改变工作负载资源的 Pod 模板，工作负载资源需要使用更新后的模板来创建 Pod， 并使用新创建的 Pod 替换旧的 Pod。</p><p>例如，StatefulSet 控制器针对每个 StatefulSet 对象确保运行中的 Pod 与当前的 Pod 模板匹配。如果编辑 StatefulSet 以更改其 Pod 模板， StatefulSet 将开始基于更新后的模板创建新的 Pod。</p><p>每个工作负载资源都实现了自己的规则，用来处理对 Pod 模板的更新。 如果你想了解更多关于 StatefulSet 的具体信息， 请阅读 StatefulSet 基础教程中的<a href="https://kubernetes.io/zh-cn/docs/tutorials/stateful-application/basic-stateful-set/#updating-statefulsets">更新策略</a>。</p><p>在节点上，<a href="https://kubernetes.io/docs/reference/generated/kubelet">kubelet</a> 并不直接监测或管理与 Pod 模板相关的细节或模板的更新，这些细节都被抽象出来。 这种抽象和关注点分离简化了整个系统的语义， 并且使得用户可以在不改变现有代码的前提下就能扩展集群的行为。</p><h2 id="Pod-更新与替换"><a href="#Pod-更新与替换" class="headerlink" title="Pod 更新与替换"></a>Pod 更新与替换<a href="#pod-update-and-replacement"></a></h2><p>正如前面章节所述，当某工作负载的 Pod 模板被改变时， 控制器会基于更新的模板创建新的 Pod 对象而不是对现有 Pod 执行更新或者修补操作。</p><p>Kubernetes 并不禁止你直接管理 Pod。对运行中的 Pod 的某些字段执行就地更新操作还是可能的。不过，类似 <a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.27/#patch-pod-v1-core"><code>patch</code></a> 和 <a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.27/#replace-pod-v1-core"><code>replace</code></a> 这类更新操作有一些限制：</p><ul><li><p>Pod 的绝大多数元数据都是不可变的。例如，你不可以改变其 <code>namespace</code>、<code>name</code>、 <code>uid</code> 或者 <code>creationTimestamp</code> 字段；<code>generation</code> 字段是比较特别的， 如果更新该字段，只能增加字段取值而不能减少。</p></li><li><p>如果 <code>metadata.deletionTimestamp</code> 已经被设置，则不可以向 <code>metadata.finalizers</code> 列表中添加新的条目。</p></li><li><p>Pod 更新不可以改变除 <code>spec.containers[*].image</code>、<code>spec.initContainers[*].image</code>、 <code>spec.activeDeadlineSeconds</code> 或 <code>spec.tolerations</code> 之外的字段。 对于 <code>spec.tolerations</code>，你只被允许添加新的条目到其中。</p></li><li><p>在更新 <code>spec.activeDeadlineSeconds</code> 字段时，以下两种更新操作是被允许的：</p><ol><li>如果该字段尚未设置，可以将其设置为一个正数；</li><li>如果该字段已经设置为一个正数，可以将其设置为一个更小的、非负的整数。</li></ol></li></ul><h3 id="资源共享和通信"><a href="#资源共享和通信" class="headerlink" title="资源共享和通信"></a>资源共享和通信<a href="#resource-sharing-and-communication"></a></h3><p>Pod 使它的成员容器间能够进行数据共享和通信。</p><h3 id="Pod-中的存储"><a href="#Pod-中的存储" class="headerlink" title="Pod 中的存储"></a>Pod 中的存储<a href="#pod-storage"></a></h3><p>一个 Pod 可以设置一组共享的存储<a href="https://kubernetes.io/zh-cn/docs/concepts/storage/volumes/">卷</a>。 Pod 中的所有容器都可以访问该共享卷，从而允许这些容器共享数据。 卷还允许 Pod 中的持久数据保留下来，即使其中的容器需要重新启动。 有关 Kubernetes 如何在 Pod 中实现共享存储并将其提供给 Pod 的更多信息， 请参考<a href="https://kubernetes.io/zh-cn/docs/concepts/storage/">存储</a>。</p><h3 id="Pod-联网"><a href="#Pod-联网" class="headerlink" title="Pod 联网"></a>Pod 联网<a href="#pod-networking"></a></h3><p>每个 Pod 都在每个地址族中获得一个唯一的 IP 地址。 Pod 中的每个容器共享网络名字空间，包括 IP 地址和网络端口。 <strong>Pod 内</strong>的容器可以使用 <code>localhost</code> 互相通信。 当 Pod 中的容器与 <strong>Pod 之外</strong>的实体通信时，它们必须协调如何使用共享的网络资源（例如端口）。</p><p>在同一个 Pod 内，所有容器共享一个 IP 地址和端口空间，并且可以通过 <code>localhost</code> 发现对方。 他们也能通过如 SystemV 信号量或 POSIX 共享内存这类标准的进程间通信方式互相通信。 不同 Pod 中的容器的 IP 地址互不相同，如果没有特殊配置，就无法通过 OS 级 IPC 进行通信。 如果某容器希望与运行于其他 Pod 中的容器通信，可以通过 IP 联网的方式实现。</p><p>Pod 中的容器所看到的系统主机名与为 Pod 配置的 <code>name</code> 属性值相同。 <a href="https://kubernetes.io/zh-cn/docs/concepts/cluster-administration/networking/">网络</a>部分提供了更多有关此内容的信息。</p><h2 id="容器的特权模式"><a href="#容器的特权模式" class="headerlink" title="容器的特权模式"></a>容器的特权模式<a href="#privileged-mode-for-containers"></a></h2><p><strong>说明：</strong></p><p>你的<a href="https://kubernetes.io/zh-cn/docs/setup/production-environment/container-runtimes">容器运行时</a>必须支持特权容器的概念才能使用这一配置。</p><p>Pod 中的所有容器都可以在特权模式下运行，以使用原本无法访问的操作系统管理权能。 此模式同时适用于 Windows 和 Linux。</p><h3 id="Linux-特权容器"><a href="#Linux-特权容器" class="headerlink" title="Linux 特权容器"></a>Linux 特权容器<a href="#linux-privileged-containers"></a></h3><p>在 Linux 中，Pod 中的所有容器都可以使用容器规约中的 <a href="https://kubernetes.io/zh-cn/docs/tasks/configure-pod-container/security-context/">安全性上下文</a>中的 <code>privileged</code>（Linux）参数启用特权模式。 这对于想要使用操作系统管理权能（Capabilities，如操纵网络堆栈和访问硬件设备）的容器很有用。</p><h3 id="Windows-特权容器"><a href="#Windows-特权容器" class="headerlink" title="Windows 特权容器"></a>Windows 特权容器<a href="#windows-privileged-containers"></a></h3><p><strong>特性状态：</strong> <code>Kubernetes v1.26 [stable]</code></p><p>在 Windows 中，你可以使用 Pod 规约中安全上下文的 <code>windowsOptions.hostProcess</code> 参数来创建 <a href="https://kubernetes.io/zh-cn/docs/tasks/configure-pod-container/create-hostprocess-pod/">Windows HostProcess Pod</a>。 这些 Pod 中的所有容器都必须以 Windows HostProcess 容器方式运行。 HostProcess Pod 可以直接运行在主机上，它也能像 Linux 特权容器一样，用于执行管理任务。</p><h2 id="静态-Pod"><a href="#静态-Pod" class="headerlink" title="静态 Pod"></a>静态 Pod<a href="#static-pods"></a></h2><p><strong>静态 Pod（Static Pod）</strong> 直接由特定节点上的 <code>kubelet</code> 守护进程管理， 不需要 <a href="https://kubernetes.io/zh-cn/docs/concepts/overview/components/#kube-apiserver">API 服务器</a>看到它们。 尽管大多数 Pod 都是通过控制面（例如，<a href="https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/deployment/">Deployment</a>） 来管理的，对于静态 Pod 而言，<code>kubelet</code> 直接监控每个 Pod，并在其失效时重启之。</p><p>静态 Pod 通常绑定到某个节点上的 <a href="https://kubernetes.io/docs/reference/generated/kubelet">kubelet</a>。 其主要用途是运行自托管的控制面。 在自托管场景中，使用 <code>kubelet</code> 来管理各个独立的<a href="https://kubernetes.io/zh-cn/docs/concepts/overview/components/#control-plane-components">控制面组件</a>。</p><p><code>kubelet</code> 自动尝试为每个静态 Pod 在 Kubernetes API 服务器上创建一个<a href="https://kubernetes.io/zh-cn/docs/reference/glossary/?all=true#term-mirror-pod">镜像 Pod</a>。 这意味着在节点上运行的 Pod 在 API 服务器上是可见的，但不可以通过 API 服务器来控制。</p><h2 id="容器探针"><a href="#容器探针" class="headerlink" title="容器探针"></a>容器探针<a href="#container-probes"></a></h2><p><strong>Probe</strong> 是由 kubelet 对容器执行的定期诊断。要执行诊断，kubelet 可以执行三种动作：</p><ul><li><code>ExecAction</code>（借助容器运行时执行）</li><li><code>TCPSocketAction</code>（由 kubelet 直接检测）</li><li><code>HTTPGetAction</code>（由 kubelet 直接检测）</li></ul><p>你可以参阅 Pod 的生命周期文档中的<a href="https://kubernetes.io/zh-cn/docs/concepts/workloads/pods/pod-lifecycle/#container-probes">探针</a>部分。</p><h2 id="接下来"><a href="#接下来" class="headerlink" title="接下来"></a>接下来<a href="#%E6%8E%A5%E4%B8%8B%E6%9D%A5"></a></h2><ul><li>了解 <a href="https://kubernetes.io/zh-cn/docs/concepts/workloads/pods/pod-lifecycle/">Pod 生命周期</a>。</li><li>了解 <a href="https://kubernetes.io/zh-cn/docs/concepts/containers/runtime-class/">RuntimeClass</a>， 以及如何使用它来配置不同的 Pod 使用不同的容器运行时配置。</li><li>了解 <a href="https://kubernetes.io/zh-cn/docs/concepts/workloads/pods/disruptions/">PodDisruptionBudget</a>， 以及你可以如何利用它在出现干扰因素时管理应用的可用性。</li><li>Pod 在 Kubernetes REST API 中是一个顶层资源。 <a href="https://kubernetes.io/zh-cn/docs/reference/kubernetes-api/workload-resources/pod-v1/">Pod</a> 对象的定义中包含了更多的细节信息。</li><li>博客<a href="https://kubernetes.io/blog/2015/06/the-distributed-system-toolkit-patterns/">分布式系统工具箱：复合容器模式</a>中解释了在同一 Pod 中包含多个容器时的几种常见布局。</li><li>了解 <a href="https://kubernetes.io/zh-cn/docs/concepts/scheduling-eviction/topology-spread-constraints/">Pod 拓扑分布约束</a>。</li></ul><p>要了解为什么 Kubernetes 会在其他资源 （如 <a href="https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/statefulset/">StatefulSet</a> 或 <a href="https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/deployment/">Deployment</a>） 封装通用的 Pod API，相关的背景信息可以在前人的研究中找到。具体包括：</p><ul><li><a href="https://aurora.apache.org/documentation/latest/reference/configuration/#job-schema">Aurora</a></li><li><a href="https://research.google.com/pubs/pub43438.html">Borg</a></li><li><a href="https://mesosphere.github.io/marathon/docs/rest-api.html">Marathon</a></li><li><a href="https://research.google/pubs/pub41684/">Omega</a></li><li><a href="https://engineering.fb.com/data-center-engineering/tupperware/">Tupperware</a>.</li></ul>]]></content>
      
      
      <categories>
          
          <category> kubernetes </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Pod 的生命周期 - KubernetesPod 的生命周期 - Kubernetes</title>
      <link href="/2023/10/03/pod-de-sheng-ming-zhou-qi-kubernetespod-de-sheng-ming-zhou-qi-kubernetes/"/>
      <url>/2023/10/03/pod-de-sheng-ming-zhou-qi-kubernetespod-de-sheng-ming-zhou-qi-kubernetes/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本文由 <a href="http://ksria.com/simpread/">简悦 SimpRead</a> 转码， 原文地址 <a href="https://kubernetes.io/zh-cn/docs/concepts/workloads/pods/pod-lifecycle/">kubernetes.io</a></p></blockquote><blockquote><p>本页面讲述 Pod 的生命周期。</p></blockquote><p>本页面讲述 Pod 的生命周期。 Pod 遵循预定义的生命周期，起始于 <code>Pending</code> <a href="#pod-phase">阶段</a>， 如果至少其中有一个主要容器正常启动，则进入 <code>Running</code>，之后取决于 Pod 中是否有容器以失败状态结束而进入 <code>Succeeded</code> 或者 <code>Failed</code> 阶段。</p><p>在 Pod 运行期间，<code>kubelet</code> 能够重启容器以处理一些失效场景。 在 Pod 内部，Kubernetes 跟踪不同容器的<a href="#container-states">状态</a>并确定使 Pod 重新变得健康所需要采取的动作。</p><p>在 Kubernetes API 中，Pod 包含规约部分和实际状态部分。 Pod 对象的状态包含了一组 <a href="#pod-conditions">Pod 状况（Conditions）</a>。 如果应用需要的话，你也可以向其中注入<a href="#pod-readiness-gate">自定义的就绪态信息</a>。</p><p>Pod 在其生命周期中只会被<a href="https://kubernetes.io/zh-cn/docs/concepts/scheduling-eviction/">调度</a>一次。 一旦 Pod 被调度（分派）到某个节点，Pod 会一直在该节点运行，直到 Pod 停止或者被<a href="#pod-termination">终止</a>。</p><h2 id="Pod-生命期"><a href="#Pod-生命期" class="headerlink" title="Pod 生命期"></a>Pod 生命期<a href="#pod-lifetime"></a></h2><p>和一个个独立的应用容器一样，Pod 也被认为是相对临时性（而不是长期存在）的实体。 Pod 会被创建、赋予一个唯一的 ID（<a href="https://kubernetes.io/zh-cn/docs/concepts/overview/working-with-objects/names/#uids">UID</a>）， 并被调度到节点，并在终止（根据重启策略）或删除之前一直运行在该节点。</p><p>如果一个<a href="https://kubernetes.io/zh-cn/docs/concepts/architecture/nodes/">节点</a>死掉了，调度到该节点的 Pod 也被计划在给定超时期限结束后<a href="#pod-garbage-collection">删除</a>。</p><p>Pod 自身不具有自愈能力。如果 Pod 被调度到某<a href="https://kubernetes.io/zh-cn/docs/concepts/architecture/nodes/">节点</a>而该节点之后失效， Pod 会被删除；类似地，Pod 无法在因节点资源耗尽或者节点维护而被驱逐期间继续存活。 Kubernetes 使用一种高级抽象来管理这些相对而言可随时丢弃的 Pod 实例， 称作<a href="https://kubernetes.io/zh-cn/docs/concepts/architecture/controller/">控制器</a>。</p><p>任何给定的 Pod （由 UID 定义）从不会被 “重新调度（rescheduled）” 到不同的节点； 相反，这一 Pod 可以被一个新的、几乎完全相同的 Pod 替换掉。 如果需要，新 Pod 的名字可以不变，但是其 UID 会不同。</p><p>如果某物声称其生命期与某 Pod 相同，例如存储<a href="https://kubernetes.io/zh-cn/docs/concepts/storage/volumes/">卷</a>， 这就意味着该对象在此 Pod （UID 亦相同）存在期间也一直存在。 如果 Pod 因为任何原因被删除，甚至某完全相同的替代 Pod 被创建时， 这个相关的对象（例如这里的卷）也会被删除并重建。</p><p><img src="https://d33wubrfki0l68.cloudfront.net/aecab1f649bc640ebef1f05581bfcc91a48038c4/728d6/images/docs/pod.svg"></p><h4 id="Pod-结构图例"><a href="#Pod-结构图例" class="headerlink" title="Pod 结构图例"></a>Pod 结构图例</h4><p>一个包含多个容器的 Pod 中包含一个用来拉取文件的程序和一个 Web 服务器， 均使用持久卷作为容器间共享的存储。</p><h2 id="Pod-阶段"><a href="#Pod-阶段" class="headerlink" title="Pod 阶段"></a>Pod 阶段<a href="#pod-phase"></a></h2><p>Pod 的 <code>status</code> 字段是一个 <a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.27/#podstatus-v1-core">PodStatus</a> 对象，其中包含一个 <code>phase</code> 字段。</p><p>Pod 的阶段（Phase）是 Pod 在其生命周期中所处位置的简单宏观概述。 该阶段并不是对容器或 Pod 状态的综合汇总，也不是为了成为完整的状态机。</p><p>Pod 阶段的数量和含义是严格定义的。 除了本文档中列举的内容外，不应该再假定 Pod 有其他的 <code>phase</code> 值。</p><p>下面是 <code>phase</code> 可能的值：</p><table><thead><tr><th>取值</th><th>描述</th></tr></thead><tbody><tr><td><code>Pending</code>（悬决）</td><td>Pod 已被 Kubernetes 系统接受，但有一个或者多个容器尚未创建亦未运行。此阶段包括等待 Pod 被调度的时间和通过网络下载镜像的时间。</td></tr><tr><td><code>Running</code>（运行中）</td><td>Pod 已经绑定到了某个节点，Pod 中所有的容器都已被创建。至少有一个容器仍在运行，或者正处于启动或重启状态。</td></tr><tr><td><code>Succeeded</code>（成功）</td><td>Pod 中的所有容器都已成功终止，并且不会再重启。</td></tr><tr><td><code>Failed</code>（失败）</td><td>Pod 中的所有容器都已终止，并且至少有一个容器是因为失败终止。也就是说，容器以非 0 状态退出或者被系统终止。</td></tr><tr><td><code>Unknown</code>（未知）</td><td>因为某些原因无法取得 Pod 的状态。这种情况通常是因为与 Pod 所在主机通信失败。</td></tr></tbody></table><p><strong>说明：</strong></p><p>当一个 Pod 被删除时，执行一些 kubectl 命令会展示这个 Pod 的状态为 <code>Terminating</code>（终止）。 这个 <code>Terminating</code> 状态并不是 Pod 阶段之一。 Pod 被赋予一个可以体面终止的期限，默认为 30 秒。 你可以使用 <code>--force</code> 参数来<a href="https://kubernetes.io/zh-cn/docs/concepts/workloads/pods/pod-lifecycle/#pod-termination-forced">强制终止 Pod</a>。</p><p>从 Kubernetes 1.27 开始，除了<a href="https://kubernetes.io/zh-cn/docs/tasks/configure-pod-container/static-pod/">静态 Pod</a> 和没有 Finalizer 的<a href="https://kubernetes.io/zh-cn/docs/concepts/workloads/pods/pod-lifecycle/#pod-termination-forced">强制终止 Pod</a> 之外，<code>kubelet</code> 会将已删除的 Pod 转换到终止阶段 （<code>Failed</code> 或 <code>Succeeded</code> 具体取决于 Pod 容器的退出状态），然后再从 API 服务器中删除。</p><p>如果某节点死掉或者与集群中其他节点失联，Kubernetes 会实施一种策略，将失去的节点上运行的所有 Pod 的 <code>phase</code> 设置为 <code>Failed</code>。</p><h2 id="容器状态"><a href="#容器状态" class="headerlink" title="容器状态"></a>容器状态<a href="#container-states"></a></h2><p>Kubernetes 会跟踪 Pod 中每个容器的状态，就像它跟踪 Pod 总体上的<a href="#pod-phase">阶段</a>一样。 你可以使用<a href="https://kubernetes.io/zh-cn/docs/concepts/containers/container-lifecycle-hooks/">容器生命周期回调</a> 来在容器生命周期中的特定时间点触发事件。</p><p>一旦<a href="https://kubernetes.io/zh-cn/docs/reference/command-line-tools-reference/kube-scheduler/">调度器</a>将 Pod 分派给某个节点，<code>kubelet</code> 就通过<a href="https://kubernetes.io/zh-cn/docs/setup/production-environment/container-runtimes">容器运行时</a>开始为 Pod 创建容器。容器的状态有三种：<code>Waiting</code>（等待）、<code>Running</code>（运行中）和 <code>Terminated</code>（已终止）。</p><p>要检查 Pod 中容器的状态，你可以使用 <code>kubectl describe pod &lt;pod 名称&gt;</code>。 其输出中包含 Pod 中每个容器的状态。</p><p>每种状态都有特定的含义：</p><h3 id="Waiting-（等待）"><a href="#Waiting-（等待）" class="headerlink" title="Waiting （等待）"></a><code>Waiting</code> （等待）<a href="#container-state-waiting"></a></h3><p>如果容器并不处在 <code>Running</code> 或 <code>Terminated</code> 状态之一，它就处在 <code>Waiting</code> 状态。 处于 <code>Waiting</code> 状态的容器仍在运行它完成启动所需要的操作：例如， 从某个容器镜像仓库拉取容器镜像，或者向容器应用 <a href="https://kubernetes.io/zh-cn/docs/concepts/configuration/secret/">Secret</a> 数据等等。 当你使用 <code>kubectl</code> 来查询包含 <code>Waiting</code> 状态的容器的 Pod 时，你也会看到一个 Reason 字段，其中给出了容器处于等待状态的原因。</p><h3 id="Running（运行中）"><a href="#Running（运行中）" class="headerlink" title="Running（运行中）"></a><code>Running</code>（运行中）<a href="#container-state-running"></a></h3><p><code>Running</code> 状态表明容器正在执行状态并且没有问题发生。 如果配置了 <code>postStart</code> 回调，那么该回调已经执行且已完成。 如果你使用 <code>kubectl</code> 来查询包含 <code>Running</code> 状态的容器的 Pod 时， 你也会看到关于容器进入 <code>Running</code> 状态的信息。</p><h3 id="Terminated（已终止）"><a href="#Terminated（已终止）" class="headerlink" title="Terminated（已终止）"></a><code>Terminated</code>（已终止）<a href="#container-state-terminated"></a></h3><p>处于 <code>Terminated</code> 状态的容器已经开始执行并且或者正常结束或者因为某些原因失败。 如果你使用 <code>kubectl</code> 来查询包含 <code>Terminated</code> 状态的容器的 Pod 时， 你会看到容器进入此状态的原因、退出代码以及容器执行期间的起止时间。</p><p>如果容器配置了 <code>preStop</code> 回调，则该回调会在容器进入 <code>Terminated</code> 状态之前执行。</p><h2 id="容器重启策略"><a href="#容器重启策略" class="headerlink" title="容器重启策略"></a>容器重启策略<a href="#restart-policy"></a></h2><p>Pod 的 <code>spec</code> 中包含一个 <code>restartPolicy</code> 字段，其可能取值包括 Always、OnFailure 和 Never。默认值是 Always。</p><p><code>restartPolicy</code> 适用于 Pod 中的所有容器。<code>restartPolicy</code> 仅针对同一节点上 <code>kubelet</code> 的容器重启动作。当 Pod 中的容器退出时，<code>kubelet</code> 会按指数回退方式计算重启的延迟（10s、20s、40s、…），其最长延迟为 5 分钟。 一旦某容器执行了 10 分钟并且没有出现问题，<code>kubelet</code> 对该容器的重启回退计时器执行重置操作。</p><h2 id="Pod-状况"><a href="#Pod-状况" class="headerlink" title="Pod 状况"></a>Pod 状况<a href="#pod-conditions"></a></h2><p>Pod 有一个 PodStatus 对象，其中包含一个 <a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.27/#podcondition-v1-core">PodConditions</a> 数组。Pod 可能通过也可能未通过其中的一些状况测试。 Kubelet 管理以下 PodCondition：</p><ul><li><code>PodScheduled</code>：Pod 已经被调度到某节点；</li><li><code>PodHasNetwork</code>：Pod 沙箱被成功创建并且配置了网络（Alpha 特性，必须被<a href="#pod-has-network">显式启用</a>）；</li><li><code>ContainersReady</code>：Pod 中所有容器都已就绪；</li><li><code>Initialized</code>：所有的 <a href="https://kubernetes.io/zh-cn/docs/concepts/workloads/pods/init-containers/">Init 容器</a>都已成功完成；</li><li><code>Ready</code>：Pod 可以为请求提供服务，并且应该被添加到对应服务的负载均衡池中。</li></ul><table><thead><tr><th>字段名称</th><th>描述</th></tr></thead><tbody><tr><td><code>type</code></td><td>Pod 状况的名称</td></tr><tr><td><code>status</code></td><td>表明该状况是否适用，可能的取值有 "<code>True</code>"、"<code>False</code>"或"<code>Unknown</code>"</td></tr><tr><td><code>lastProbeTime</code></td><td>上次探测 Pod 状况时的时间戳</td></tr><tr><td><code>lastTransitionTime</code></td><td>Pod 上次从一种状态转换到另一种状态时的时间戳</td></tr><tr><td><code>reason</code></td><td>机器可读的、驼峰编码（UpperCamelCase）的文字，表述上次状况变化的原因</td></tr><tr><td><code>message</code></td><td>人类可读的消息，给出上次状态转换的详细信息</td></tr></tbody></table><h3 id="Pod-就绪态"><a href="#Pod-就绪态" class="headerlink" title="Pod 就绪态"></a>Pod 就绪态<a href="#pod-readiness-gate"></a></h3><p><strong>特性状态：</strong> <code>Kubernetes v1.14 [stable]</code></p><p>你的应用可以向 PodStatus 中注入额外的反馈或者信号：<strong>Pod Readiness（Pod 就绪态）</strong>。 要使用这一特性，可以设置 Pod 规约中的 <code>readinessGates</code> 列表，为 kubelet 提供一组额外的状况供其评估 Pod 就绪态时使用。</p><p>就绪态门控基于 Pod 的 <code>status.conditions</code> 字段的当前值来做决定。 如果 Kubernetes 无法在 <code>status.conditions</code> 字段中找到某状况， 则该状况的状态值默认为 “<code>False</code>“。</p><p>这里是一个例子：</p><pre class="line-numbers language-none"><code class="language-none">kind: Pod...spec:  readinessGates:    - conditionType: "www.example.com/feature-1"status:  conditions:    - type: Ready                              # 内置的 Pod 状况      status: "False"      lastProbeTime: null      lastTransitionTime: 2018-01-01T00:00:00Z    - type: "www.example.com/feature-1"        # 额外的 Pod 状况      status: "False"      lastProbeTime: null      lastTransitionTime: 2018-01-01T00:00:00Z  containerStatuses:    - containerID: docker://abcd...      ready: true...<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>你所添加的 Pod 状况名称必须满足 Kubernetes <a href="https://kubernetes.io/zh-cn/docs/concepts/overview/working-with-objects/labels/#syntax-and-character-set">标签键名格式</a>。</p><h3 id="Pod-就绪态的状态"><a href="#Pod-就绪态的状态" class="headerlink" title="Pod 就绪态的状态"></a>Pod 就绪态的状态<a href="#pod-readiness-status"></a></h3><p>命令 <code>kubectl patch</code> 不支持修改对象的状态。 如果需要设置 Pod 的 <code>status.conditions</code>，应用或者 <a href="https://kubernetes.io/zh-cn/docs/concepts/extend-kubernetes/operator/">Operators</a> 需要使用 <code>PATCH</code> 操作。你可以使用 <a href="https://kubernetes.io/zh-cn/docs/reference/using-api/client-libraries/">Kubernetes 客户端库</a>之一来编写代码， 针对 Pod 就绪态设置定制的 Pod 状况。</p><p>对于使用定制状况的 Pod 而言，只有当下面的陈述都适用时，该 Pod 才会被评估为就绪：</p><ul><li>Pod 中所有容器都已就绪；</li><li><code>readinessGates</code> 中的所有状况都为 <code>True</code> 值。</li></ul><p>当 Pod 的容器都已就绪，但至少一个定制状况没有取值或者取值为 <code>False</code>， <code>kubelet</code> 将 Pod 的<a href="#pod-conditions">状况</a>设置为 <code>ContainersReady</code>。</p><h3 id="Pod-网络就绪"><a href="#Pod-网络就绪" class="headerlink" title="Pod 网络就绪"></a>Pod 网络就绪<a href="#pod-has-network"></a></h3><p><strong>特性状态：</strong> <code>Kubernetes v1.25 [alpha]</code></p><p>在 Pod 被调度到某节点后，它需要被 Kubelet 接受并且挂载所需的卷。 一旦这些阶段完成，Kubelet 将与容器运行时（使用<a href="https://kubernetes.io/zh-cn/docs/concepts/overview/components/#container-runtime">容器运行时接口（Container Runtime Interface；CRI）</a>） 一起为 Pod 生成运行时沙箱并配置网络。如果启用了 <code>PodHasNetworkCondition</code> <a href="https://kubernetes.io/zh-cn/docs/reference/command-line-tools-reference/feature-gates/">特性门控</a>， kubelet 会通过 Pod 的 <code>status.conditions</code> 字段中的 <code>PodHasNetwork</code> 状况来报告 Pod 是否达到了初始化里程碑。</p><p>当 kubelet 检测到 Pod 不具备配置了网络的运行时沙箱时，<code>PodHasNetwork</code> 状况将被设置为 <code>False</code>。 以下场景中将会发生这种状况：</p><ul><li>在 Pod 生命周期的早期阶段，kubelet 还没有开始使用容器运行时为 Pod 设置沙箱时。</li><li>在 Pod 生命周期的末期阶段，Pod 的沙箱由于以下原因被销毁时：<ul><li>节点重启时 Pod 没有被驱逐</li><li>对于使用虚拟机进行隔离的容器运行时，Pod 沙箱虚拟机重启时，需要创建一个新的沙箱和全新的容器网络配置。</li></ul></li></ul><p>在运行时插件成功完成 Pod 的沙箱创建和网络配置后， kubelet 会将 <code>PodHasNetwork</code> 状况设置为 <code>True</code>。 当 <code>PodHasNetwork</code> 状况设置为 <code>True</code> 后， Kubelet 可以开始拉取容器镜像和创建容器。</p><p>对于带有 Init 容器的 Pod，kubelet 会在 Init 容器成功完成后将 <code>Initialized</code> 状况设置为 <code>True</code> （这发生在运行时成功创建沙箱和配置网络之后）， 对于没有 Init 容器的 Pod，kubelet 会在创建沙箱和网络配置开始之前将 <code>Initialized</code> 状况设置为 <code>True</code>。</p><h3 id="Pod-调度就绪态"><a href="#Pod-调度就绪态" class="headerlink" title="Pod 调度就绪态"></a>Pod 调度就绪态<a href="#pod-scheduling-readiness-gate"></a></h3><p><strong>特性状态：</strong> <code>Kubernetes v1.26 [alpha]</code></p><p>有关详细信息，请参阅 <a href="https://kubernetes.io/zh-cn/docs/concepts/scheduling-eviction/pod-scheduling-readiness/">Pod 调度就绪态</a>。</p><h2 id="容器探针"><a href="#容器探针" class="headerlink" title="容器探针"></a>容器探针<a href="#container-probes"></a></h2><p><strong>probe</strong> 是由 <a href="https://kubernetes.io/zh-cn/docs/reference/command-line-tools-reference/kubelet/">kubelet</a> 对容器执行的定期诊断。 要执行诊断，kubelet 既可以在容器内执行代码，也可以发出一个网络请求。</p><h3 id="检查机制"><a href="#检查机制" class="headerlink" title="检查机制"></a>检查机制<a href="#probe-check-methods"></a></h3><p>使用探针来检查容器有四种不同的方法。 每个探针都必须准确定义为这四种机制中的一种：</p><p><code>exec</code></p><p>在容器内执行指定命令。如果命令退出时返回码为 0 则认为诊断成功。</p><p><code>grpc</code></p><p>使用 <a href="https://grpc.io/">gRPC</a> 执行一个远程过程调用。 目标应该实现 <a href="https://grpc.io/grpc/core/md_doc_health-checking.html">gRPC 健康检查</a>。 如果响应的状态是 “SERVING”，则认为诊断成功。</p><p><code>httpGet</code></p><p>对容器的 IP 地址上指定端口和路径执行 HTTP <code>GET</code> 请求。如果响应的状态码大于等于 200 且小于 400，则诊断被认为是成功的。</p><p><code>tcpSocket</code></p><p>对容器的 IP 地址上的指定端口执行 TCP 检查。如果端口打开，则诊断被认为是成功的。 如果远程系统（容器）在打开连接后立即将其关闭，这算作是健康的。</p><p><strong>注意：</strong> 和其他机制不同，<code>exec</code> 探针的实现涉及每次执行时创建 / 复制多个进程。 因此，在集群中具有较高 pod 密度、较低的 <code>initialDelaySeconds</code> 和 <code>periodSeconds</code> 时长的时候， 配置任何使用 exec 机制的探针可能会增加节点的 CPU 负载。 这种场景下，请考虑使用其他探针机制以避免额外的开销。</p><h3 id="探测结果"><a href="#探测结果" class="headerlink" title="探测结果"></a>探测结果<a href="#probe-outcome"></a></h3><p>每次探测都将获得以下三种结果之一：</p><p><code>Success</code>（成功）</p><p>容器通过了诊断。</p><p><code>Failure</code>（失败）</p><p>容器未通过诊断。</p><p><code>Unknown</code>（未知）</p><p>诊断失败，因此不会采取任何行动。</p><h3 id="探测类型"><a href="#探测类型" class="headerlink" title="探测类型"></a>探测类型<a href="#types-of-probe"></a></h3><p>针对运行中的容器，<code>kubelet</code> 可以选择是否执行以下三种探针，以及如何针对探测结果作出反应：</p><p><code>livenessProbe</code></p><p>指示容器是否正在运行。如果存活态探测失败，则 kubelet 会杀死容器， 并且容器将根据其<a href="#restart-policy">重启策略</a>决定未来。如果容器不提供存活探针， 则默认状态为 <code>Success</code>。</p><p><code>readinessProbe</code></p><p>指示容器是否准备好为请求提供服务。如果就绪态探测失败， 端点控制器将从与 Pod 匹配的所有服务的端点列表中删除该 Pod 的 IP 地址。 初始延迟之前的就绪态的状态值默认为 <code>Failure</code>。 如果容器不提供就绪态探针，则默认状态为 <code>Success</code>。</p><p><code>startupProbe</code></p><p>指示容器中的应用是否已经启动。如果提供了启动探针，则所有其他探针都会被 禁用，直到此探针成功为止。如果启动探测失败，<code>kubelet</code> 将杀死容器， 而容器依其<a href="#restart-policy">重启策略</a>进行重启。 如果容器没有提供启动探测，则默认状态为 <code>Success</code>。</p><p>如欲了解如何设置存活态、就绪态和启动探针的进一步细节， 可以参阅<a href="https://kubernetes.io/zh-cn/docs/tasks/configure-pod-container/configure-liveness-readiness-startup-probes/">配置存活态、就绪态和启动探针</a>。</p><h4 id="何时该使用存活态探针"><a href="#何时该使用存活态探针" class="headerlink" title="何时该使用存活态探针?"></a>何时该使用存活态探针?<a href="#when-should-you-use-a-liveness-probe"></a></h4><p>如果容器中的进程能够在遇到问题或不健康的情况下自行崩溃，则不一定需要存活态探针； <code>kubelet</code> 将根据 Pod 的 <code>restartPolicy</code> 自动执行修复操作。</p><p>如果你希望容器在探测失败时被杀死并重新启动，那么请指定一个存活态探针， 并指定 <code>restartPolicy</code> 为 “<code>Always</code>“或”<code>OnFailure</code>“。</p><h4 id="何时该使用就绪态探针"><a href="#何时该使用就绪态探针" class="headerlink" title="何时该使用就绪态探针?"></a>何时该使用就绪态探针?<a href="#when-should-you-use-a-readiness-probe"></a></h4><p>如果要仅在探测成功时才开始向 Pod 发送请求流量，请指定就绪态探针。 在这种情况下，就绪态探针可能与存活态探针相同，但是规约中的就绪态探针的存在意味着 Pod 将在启动阶段不接收任何数据，并且只有在探针探测成功后才开始接收数据。</p><p>如果你希望容器能够自行进入维护状态，也可以指定一个就绪态探针， 检查某个特定于就绪态的因此不同于存活态探测的端点。</p><p>如果你的应用程序对后端服务有严格的依赖性，你可以同时实现存活态和就绪态探针。 当应用程序本身是健康的，存活态探针检测通过后，就绪态探针会额外检查每个所需的后端服务是否可用。 这可以帮助你避免将流量导向只能返回错误信息的 Pod。</p><p>如果你的容器需要在启动期间加载大型数据、配置文件或执行迁移， 你可以使用<a href="#when-should-you-use-a-startup-probe">启动探针</a>。 然而，如果你想区分已经失败的应用和仍在处理其启动数据的应用，你可能更倾向于使用就绪探针。</p><p><strong>说明：</strong></p><p>请注意，如果你只是想在 Pod 被删除时能够排空请求，则不一定需要使用就绪态探针； 在删除 Pod 时，Pod 会自动将自身置于未就绪状态，无论就绪态探针是否存在。 等待 Pod 中的容器停止期间，Pod 会一直处于未就绪状态。</p><h4 id="何时该使用启动探针？"><a href="#何时该使用启动探针？" class="headerlink" title="何时该使用启动探针？"></a>何时该使用启动探针？<a href="#when-should-you-use-a-startup-probe"></a></h4><p>对于所包含的容器需要较长时间才能启动就绪的 Pod 而言，启动探针是有用的。 你不再需要配置一个较长的存活态探测时间间隔，只需要设置另一个独立的配置选定， 对启动期间的容器执行探测，从而允许使用远远超出存活态时间间隔所允许的时长。</p><p>如果你的容器启动时间通常超出 <code>initialDelaySeconds + failureThreshold × periodSeconds</code> 总值，你应该设置一个启动探测，对存活态探针所使用的同一端点执行检查。 <code>periodSeconds</code> 的默认值是 10 秒。你应该将其 <code>failureThreshold</code> 设置得足够高， 以便容器有充足的时间完成启动，并且避免更改存活态探针所使用的默认值。 这一设置有助于减少死锁状况的发生。</p><h2 id="Pod-的终止"><a href="#Pod-的终止" class="headerlink" title="Pod 的终止"></a>Pod 的终止<a href="#pod-termination"></a></h2><p>由于 Pod 所代表的是在集群中节点上运行的进程，当不再需要这些进程时允许其体面地终止是很重要的。 一般不应武断地使用 <code>KILL</code> 信号终止它们，导致这些进程没有机会完成清理操作。</p><p>设计的目标是令你能够请求删除进程，并且知道进程何时被终止，同时也能够确保删除操作终将完成。 当你请求删除某个 Pod 时，集群会记录并跟踪 Pod 的体面终止周期， 而不是直接强制地杀死 Pod。在存在强制关闭设施的前提下， <a href="https://kubernetes.io/docs/reference/generated/kubelet">kubelet</a> 会尝试体面地终止 Pod。</p><p>通常情况下，容器运行时会发送一个 TERM 信号到每个容器中的主进程。 很多容器运行时都能够注意到容器镜像中 <code>STOPSIGNAL</code> 的值，并发送该信号而不是 TERM。 一旦超出了体面终止限期，容器运行时会向所有剩余进程发送 KILL 信号，之后 Pod 就会被从 <a href="https://kubernetes.io/zh-cn/docs/concepts/overview/components/#kube-apiserver">API 服务器</a>上移除。 如果 <code>kubelet</code> 或者容器运行时的管理服务在等待进程终止期间被重启， 集群会从头开始重试，赋予 Pod 完整的体面终止限期。</p><p>下面是一个例子：</p><ol><li><p>你使用 <code>kubectl</code> 工具手动删除某个特定的 Pod，而该 Pod 的体面终止限期是默认值（30 秒）。</p></li><li><p>API 服务器中的 Pod 对象被更新，记录涵盖体面终止限期在内 Pod 的最终死期，超出所计算时间点则认为 Pod 已死（dead）。 如果你使用 <code>kubectl describe</code> 来查验你正在删除的 Pod，该 Pod 会显示为 “Terminating” （正在终止）。 在 Pod 运行所在的节点上：<code>kubelet</code> 一旦看到 Pod 被标记为正在终止（已经设置了体面终止限期），<code>kubelet</code> 即开始本地的 Pod 关闭过程。</p><ol><li><p>如果 Pod 中的容器之一定义了 <code>preStop</code> <a href="https://kubernetes.io/zh-cn/docs/concepts/containers/container-lifecycle-hooks">回调</a>， <code>kubelet</code> 开始在容器内运行该回调逻辑。如果超出体面终止限期时， <code>preStop</code> 回调逻辑仍在运行，<code>kubelet</code> 会请求给予该 Pod 的宽限期一次性增加 2 秒钟。</p><p>如果 <code>preStop</code> 回调在体面期结束后仍在运行，kubelet 将请求短暂的、一次性的体面期延长 2 秒。</p><p><strong>说明：</strong></p><pre class="line-numbers language-none"><code class="language-none">如果 `preStop` 回调所需要的时间长于默认的体面终止限期，你必须修改`terminationGracePeriodSeconds` 属性值来使其正常工作。        <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p><code>kubelet</code> 接下来触发容器运行时发送 TERM 信号给每个容器中的进程 1。</p><p><strong>说明：</strong></p><pre class="line-numbers language-none"><code class="language-none">Pod 中的容器会在不同时刻收到 TERM 信号，接收顺序也是不确定的。如果关闭的顺序很重要，可以考虑使用 `preStop` 回调逻辑来协调。        <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li></ol></li><li><p>在 <code>kubelet</code> 启动 Pod 的体面关闭逻辑的同时，控制平面会评估是否将关闭的 Pod 从对应的 EndpointSlice（和端点）对象中移除，过滤条件是 Pod 被对应的<a href="https://kubernetes.io/zh-cn/docs/concepts/services-networking/service/">服务</a>以某 <a href="https://kubernetes.io/zh-cn/docs/concepts/overview/working-with-objects/labels/">选择算符</a>选定。 <a href="https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/replicaset/">ReplicaSet</a> 和其他工作负载资源不再将关闭进程中的 Pod 视为合法的、能够提供服务的副本。</p><p>关闭动作很慢的 Pod 不应继续处理常规服务请求，而应开始终止并完成对打开的连接的处理。 一些应用程序不仅需要完成对打开的连接的处理，还需要更进一步的体面终止逻辑 - 比如：排空和完成会话。</p><p>任何正在终止的 Pod 所对应的端点都不会立即从 EndpointSlice 中被删除，EndpointSlice API（以及传统的 Endpoints API）会公开一个状态来指示其处于 <a href="https://kubernetes.io/zh-cn/docs/concepts/services-networking/endpoint-slices/#conditions">终止状态</a>。 正在终止的端点始终将其 <code>ready</code> 状态设置为 <code>false</code>（为了向后兼容 1.26 之前的版本）， 因此负载均衡器不会将其用于常规流量。</p><p>如果需要排空正被终止的 Pod 上的流量，可以将 <code>serving</code> 状况作为实际的就绪状态。你可以在教程 <a href="https://kubernetes.io/zh-cn/docs/tutorials/services/pods-and-endpoint-termination-flow/">探索 Pod 及其端点的终止行为</a> 中找到有关如何实现连接排空的更多详细信息。</p></li></ol><p><strong>说明：</strong></p><p>如果你的集群中没有启用 EndpointSliceTerminatingCondition 特性门控 （该门控从 Kubernetes 1.22 开始默认开启，在 1.26 中锁定为默认）， 那么一旦 Pod 的终止宽限期开始，Kubernetes 控制平面就会从所有的相关 EndpointSlices 中移除 Pod。 上述行为是在 EndpointSliceTerminatingCondition 特性门控被启用时描述的。</p><ol><li><p>超出终止宽限期限时，<code>kubelet</code> 会触发强制关闭过程。容器运行时会向 Pod 中所有容器内仍在运行的进程发送 <code>SIGKILL</code> 信号。 <code>kubelet</code> 也会清理隐藏的 <code>pause</code> 容器，如果容器运行时使用了这种容器的话。</p></li><li><p><code>kubelet</code> 将 Pod 转换到终止阶段（<code>Failed</code> 或 <code>Succeeded</code> 具体取决于其容器的结束状态）。 这一步从 1.27 版本开始得到保证。</p></li><li><p><code>kubelet</code> 触发强制从 API 服务器上删除 Pod 对象的逻辑，并将体面终止限期设置为 0 （这意味着马上删除）。</p></li><li><p>API 服务器删除 Pod 的 API 对象，从任何客户端都无法再看到该对象。</p></li></ol><h3 id="强制终止-Pod"><a href="#强制终止-Pod" class="headerlink" title="强制终止 Pod"></a>强制终止 Pod<a href="#pod-termination-forced"></a></h3><p><strong>注意：</strong></p><p>对于某些工作负载及其 Pod 而言，强制删除很可能会带来某种破坏。</p><p>默认情况下，所有的删除操作都会附有 30 秒钟的宽限期限。 <code>kubectl delete</code> 命令支持 <code>--grace-period=&lt;seconds&gt;</code> 选项，允许你重载默认值， 设定自己希望的期限值。</p><p>将宽限期限强制设置为 <code>0</code> 意味着立即从 API 服务器删除 Pod。 如果 Pod 仍然运行于某节点上，强制删除操作会触发 <code>kubelet</code> 立即执行清理操作。</p><p><strong>说明：</strong></p><p>你必须在设置 <code>--grace-period=0</code> 的同时额外设置 <code>--force</code> 参数才能发起强制删除请求。</p><p>执行强制删除操作时，API 服务器不再等待来自 <code>kubelet</code> 的、关于 Pod 已经在原来运行的节点上终止执行的确认消息。 API 服务器直接删除 Pod 对象，这样新的与之同名的 Pod 即可以被创建。 在节点侧，被设置为立即终止的 Pod 仍然会在被强行杀死之前获得一点点的宽限时间。</p><p><strong>注意：</strong></p><p>马上删除时不等待确认正在运行的资源已被终止。这些资源可能会无限期地继续在集群上运行。</p><p>如果你需要强制删除 StatefulSet 的 Pod， 请参阅<a href="https://kubernetes.io/zh-cn/docs/tasks/run-application/force-delete-stateful-set-pod/">从 StatefulSet 中删除 Pod</a> 的任务文档。</p><h3 id="Pod-的垃圾收集"><a href="#Pod-的垃圾收集" class="headerlink" title="Pod 的垃圾收集"></a>Pod 的垃圾收集<a href="#pod-garbage-collection"></a></h3><p>对于已失败的 Pod 而言，对应的 API 对象仍然会保留在集群的 API 服务器上， 直到用户或者<a href="https://kubernetes.io/zh-cn/docs/concepts/architecture/controller/">控制器</a>进程显式地将其删除。</p><p>Pod 的垃圾收集器（PodGC）是控制平面的控制器，它会在 Pod 个数超出所配置的阈值 （根据 <code>kube-controller-manager</code> 的 <code>terminated-pod-gc-threshold</code> 设置）时删除已终止的 Pod（阶段值为 <code>Succeeded</code> 或 <code>Failed</code>）。 这一行为会避免随着时间演进不断创建和终止 Pod 而引起的资源泄露问题。</p><p>此外，PodGC 会清理满足以下任一条件的所有 Pod：</p><ol><li>孤儿 Pod - 绑定到不再存在的节点，</li><li>计划外终止的 Pod</li><li>终止过程中的 Pod，当启用 <code>NodeOutOfServiceVolumeDetach</code> 特性门控时， 绑定到有 <a href="https://kubernetes.io/zh-cn/docs/reference/labels-annotations-taints/#node-kubernetes-io-out-of-service"><code>node.kubernetes.io/out-of-service</code></a> 污点的未就绪节点。</li></ol><p>若启用 <code>PodDisruptionConditions</code> 特性门控，在清理 Pod 的同时， 如果它们处于非终止状态阶段，PodGC 也会将它们标记为失败。 此外，PodGC 在清理孤儿 Pod 时会添加 Pod 干扰状况。参阅 <a href="https://kubernetes.io/zh-cn/docs/concepts/workloads/pods/disruptions#pod-disruption-conditions">Pod 干扰状况</a> 了解更多详情。</p><h2 id="接下来"><a href="#接下来" class="headerlink" title="接下来"></a>接下来<a href="#%E6%8E%A5%E4%B8%8B%E6%9D%A5"></a></h2><ul><li>动手实践<a href="https://kubernetes.io/zh-cn/docs/tasks/configure-pod-container/attach-handler-lifecycle-event/">为容器生命周期时间关联处理程序</a>。</li><li>动手实践<a href="https://kubernetes.io/zh-cn/docs/tasks/configure-pod-container/configure-liveness-readiness-startup-probes/">配置存活态、就绪态和启动探针</a>。</li><li>进一步了解<a href="https://kubernetes.io/zh-cn/docs/concepts/containers/container-lifecycle-hooks/">容器生命周期回调</a>。</li><li>关于 API 中定义的有关 Pod 和容器状态的详细规范信息， 可参阅 API 参考文档中 Pod 的 <a href="https://kubernetes.io/zh-cn/docs/reference/kubernetes-api/workload-resources/pod-v1/#PodStatus"><code>status</code></a> 字段。</li></ul>]]></content>
      
      
      <categories>
          
          <category> kubernetes </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>test</title>
      <link href="/2023/10/03/test/"/>
      <url>/2023/10/03/test/</url>
      
        <content type="html"><![CDATA[<pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> Service<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> gitlab<span class="token key atrule">spec</span><span class="token punctuation">:</span>  <span class="token key atrule">type</span><span class="token punctuation">:</span> NodePort  <span class="token key atrule">ports</span><span class="token punctuation">:</span>  <span class="token comment"># Port上的映射端口</span>  <span class="token punctuation">-</span> <span class="token key atrule">port</span><span class="token punctuation">:</span> <span class="token number">443</span>    <span class="token key atrule">targetPort</span><span class="token punctuation">:</span> <span class="token number">443</span>    <span class="token key atrule">name</span><span class="token punctuation">:</span> gitlab443  <span class="token punctuation">-</span> <span class="token key atrule">port</span><span class="token punctuation">:</span> <span class="token number">80</span>    <span class="token key atrule">targetPort</span><span class="token punctuation">:</span> <span class="token number">80</span>    <span class="token key atrule">name</span><span class="token punctuation">:</span> gitlab80  <span class="token punctuation">-</span> <span class="token key atrule">port</span><span class="token punctuation">:</span> <span class="token number">22</span>    <span class="token key atrule">targetPort</span><span class="token punctuation">:</span> <span class="token number">22</span>    <span class="token key atrule">name</span><span class="token punctuation">:</span> gitlab22  <span class="token key atrule">selector</span><span class="token punctuation">:</span>    <span class="token key atrule">app</span><span class="token punctuation">:</span> gitlab <span class="token punctuation">---</span> <span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> apps/v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> Deployment<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> gitlab<span class="token key atrule">spec</span><span class="token punctuation">:</span>  <span class="token key atrule">selector</span><span class="token punctuation">:</span>    <span class="token key atrule">matchLabels</span><span class="token punctuation">:</span>      <span class="token key atrule">app</span><span class="token punctuation">:</span> gitlab  <span class="token key atrule">revisionHistoryLimit</span><span class="token punctuation">:</span> <span class="token number">2</span>  <span class="token key atrule">template</span><span class="token punctuation">:</span>    <span class="token key atrule">metadata</span><span class="token punctuation">:</span>      <span class="token key atrule">labels</span><span class="token punctuation">:</span>        <span class="token key atrule">app</span><span class="token punctuation">:</span> gitlab    <span class="token key atrule">spec</span><span class="token punctuation">:</span>      <span class="token key atrule">containers</span><span class="token punctuation">:</span>      <span class="token comment"># 应用的镜像</span>      <span class="token punctuation">-</span> <span class="token key atrule">image</span><span class="token punctuation">:</span> gitlab/gitlab<span class="token punctuation">-</span>ce         <span class="token key atrule">name</span><span class="token punctuation">:</span> gitlab        <span class="token key atrule">imagePullPolicy</span><span class="token punctuation">:</span> IfNotPresent        <span class="token comment"># 应用的内部端口</span>        <span class="token key atrule">ports</span><span class="token punctuation">:</span>        <span class="token punctuation">-</span> <span class="token key atrule">containerPort</span><span class="token punctuation">:</span> <span class="token number">443</span>          <span class="token key atrule">name</span><span class="token punctuation">:</span> gitlab443        <span class="token punctuation">-</span> <span class="token key atrule">containerPort</span><span class="token punctuation">:</span> <span class="token number">80</span>          <span class="token key atrule">name</span><span class="token punctuation">:</span> gitlab80        <span class="token punctuation">-</span> <span class="token key atrule">containerPort</span><span class="token punctuation">:</span> <span class="token number">22</span>          <span class="token key atrule">name</span><span class="token punctuation">:</span> gitlab22        <span class="token key atrule">volumeMounts</span><span class="token punctuation">:</span>        <span class="token comment"># gitlab持久化</span>        <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> gitlab<span class="token punctuation">-</span>persistent<span class="token punctuation">-</span>config          <span class="token key atrule">mountPath</span><span class="token punctuation">:</span> /etc/gitlab        <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> gitlab<span class="token punctuation">-</span>persistent<span class="token punctuation">-</span>logs          <span class="token key atrule">mountPath</span><span class="token punctuation">:</span> /var/log/gitlab        <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> gitlab<span class="token punctuation">-</span>persistent<span class="token punctuation">-</span>data          <span class="token key atrule">mountPath</span><span class="token punctuation">:</span> /var/opt/gitlab      <span class="token key atrule">imagePullSecrets</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> devops<span class="token punctuation">-</span>repo      <span class="token key atrule">volumes</span><span class="token punctuation">:</span>      <span class="token comment"># 使用nfs互联网存储</span>      <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> gitlab<span class="token punctuation">-</span>persistent<span class="token punctuation">-</span>config        <span class="token key atrule">nfs</span><span class="token punctuation">:</span>          <span class="token key atrule">server</span><span class="token punctuation">:</span> 192.168.17.81          <span class="token key atrule">path</span><span class="token punctuation">:</span> /home/k8s<span class="token punctuation">-</span>nfs/gitlab/config      <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> gitlab<span class="token punctuation">-</span>persistent<span class="token punctuation">-</span>logs        <span class="token key atrule">nfs</span><span class="token punctuation">:</span>          <span class="token key atrule">server</span><span class="token punctuation">:</span> 192.168.17.81          <span class="token key atrule">path</span><span class="token punctuation">:</span> /home/k8s<span class="token punctuation">-</span>nfs/gitlab/logs      <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> gitlab<span class="token punctuation">-</span>persistent<span class="token punctuation">-</span>data        <span class="token key atrule">nfs</span><span class="token punctuation">:</span>          <span class="token key atrule">server</span><span class="token punctuation">:</span> 192.168.17.81          <span class="token key atrule">path</span><span class="token punctuation">:</span> /home/k8s<span class="token punctuation">-</span>nfs/gitlab/data<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>容器运行时类（Runtime Class） - Kubernetes 容器运行时类（Runtime Class） - Kubernetes</title>
      <link href="/2023/10/03/rong-qi-yun-xing-shi-lei-runtime-class-kubernetes-rong-qi-yun-xing-shi-lei-runtime-class-kubernetes/"/>
      <url>/2023/10/03/rong-qi-yun-xing-shi-lei-runtime-class-kubernetes-rong-qi-yun-xing-shi-lei-runtime-class-kubernetes/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本文由 <a href="http://ksria.com/simpread/">简悦 SimpRead</a> 转码， 原文地址 <a href="https://kubernetes.io/zh-cn/docs/concepts/containers/runtime-class/">kubernetes.io</a></p></blockquote><blockquote><p>特性状态： Kubernetes v1.20 [stable] 本页面描述了 RuntimeClass 资源和运行时的选择机制。</p></blockquote><p><strong>特性状态：</strong> <code>Kubernetes v1.20 [stable]</code></p><p>本页面描述了 RuntimeClass 资源和运行时的选择机制。</p><p>RuntimeClass 是一个用于选择容器运行时配置的特性，容器运行时配置用于运行 Pod 中的容器。</p><h2 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机<a href="#motivation"></a></h2><p>你可以在不同的 Pod 设置不同的 RuntimeClass，以提供性能与安全性之间的平衡。 例如，如果你的部分工作负载需要高级别的信息安全保证，你可以决定在调度这些 Pod 时尽量使它们在使用硬件虚拟化的容器运行时中运行。 这样，你将从这些不同运行时所提供的额外隔离中获益，代价是一些额外的开销。</p><p>你还可以使用 RuntimeClass 运行具有相同容器运行时但具有不同设置的 Pod。</p><h2 id="设置"><a href="#设置" class="headerlink" title="设置"></a>设置<a href="#setup"></a></h2><ol><li>在节点上配置 CRI 的实现（取决于所选用的运行时）</li><li>创建相应的 RuntimeClass 资源</li></ol><h3 id="1-在节点上配置-CRI-实现"><a href="#1-在节点上配置-CRI-实现" class="headerlink" title="1. 在节点上配置 CRI 实现"></a>1. 在节点上配置 CRI 实现<a href="#1-%E5%9C%A8%E8%8A%82%E7%82%B9%E4%B8%8A%E9%85%8D%E7%BD%AE-cri-%E5%AE%9E%E7%8E%B0"></a></h3><p>RuntimeClass 的配置依赖于运行时接口（CRI）的实现。 根据你使用的 CRI 实现，查阅相关的文档（<a href="#cri-configuration">下方</a>）来了解如何配置。</p><p><strong>说明：</strong></p><p>RuntimeClass 假设集群中的节点配置是同构的（换言之，所有的节点在容器运行时方面的配置是相同的）。 如果需要支持异构节点，配置方法请参阅下面的<a href="#scheduling">调度</a>。</p><p>所有这些配置都具有相应的 <code>handler</code> 名，并被 RuntimeClass 引用。 handler 必须是有效的 <a href="https://kubernetes.io/zh-cn/docs/concepts/overview/working-with-objects/names/#dns-label-names">DNS 标签名</a>。</p><h3 id="2-创建相应的-RuntimeClass-资源"><a href="#2-创建相应的-RuntimeClass-资源" class="headerlink" title="2. 创建相应的 RuntimeClass 资源"></a>2. 创建相应的 RuntimeClass 资源<a href="#2-%E5%88%9B%E5%BB%BA%E7%9B%B8%E5%BA%94%E7%9A%84-runtimeclass-%E8%B5%84%E6%BA%90"></a></h3><p>在上面步骤 1 中，每个配置都需要有一个用于标识配置的 <code>handler</code>。 针对每个 handler 需要创建一个 RuntimeClass 对象。</p><p>RuntimeClass 资源当前只有两个重要的字段：RuntimeClass 名 (<code>metadata.name</code>) 和 handler (<code>handler</code>)。 对象定义如下所示：</p><pre class="line-numbers language-none"><code class="language-none"># RuntimeClass 定义于 node.k8s.io API 组apiVersion: node.k8s.io/v1kind: RuntimeClassmetadata:  # 用来引用 RuntimeClass 的名字  # RuntimeClass 是一个集群层面的资源  name: myclass# 对应的 CRI 配置的名称handler: myconfiguration<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>RuntimeClass 对象的名称必须是有效的 <a href="https://kubernetes.io/zh-cn/docs/concepts/overview/working-with-objects/names#dns-subdomain-names">DNS 子域名</a>。</p><p><strong>说明：</strong></p><p>建议将 RuntimeClass 写操作（create、update、patch 和 delete）限定于集群管理员使用。 通常这是默认配置。参阅<a href="https://kubernetes.io/zh-cn/docs/reference/access-authn-authz/authorization/">授权概述</a>了解更多信息。</p><h2 id="使用说明"><a href="#使用说明" class="headerlink" title="使用说明"></a>使用说明<a href="#usage"></a></h2><p>一旦完成集群中 RuntimeClasses 的配置， 你可以在 Pod spec 中指定 <code>runtimeClassName</code> 来使用它。例如:</p><pre class="line-numbers language-none"><code class="language-none">apiVersion: v1kind: Podmetadata:  name: mypodspec:  runtimeClassName: myclass  # ...<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这一设置会告诉 kubelet 使用所指的 RuntimeClass 来运行该 Pod。 如果所指的 RuntimeClass 不存在或者 CRI 无法运行相应的 handler， 那么 Pod 将会进入 <code>Failed</code> 终止<a href="https://kubernetes.io/zh-cn/docs/concepts/workloads/pods/pod-lifecycle/#pod-phase">阶段</a>。 你可以查看相应的<a href="https://kubernetes.io/zh-cn/docs/tasks/debug/debug-application/debug-running-pod/">事件</a>， 获取执行过程中的错误信息。</p><p>如果未指定 <code>runtimeClassName</code>，则将使用默认的 RuntimeHandler，相当于禁用 RuntimeClass 功能特性。</p><h3 id="CRI-配置"><a href="#CRI-配置" class="headerlink" title="CRI 配置"></a>CRI 配置<a href="#cri-configuration"></a></h3><p>关于如何安装 CRI 运行时，请查阅 <a href="https://kubernetes.io/zh-cn/docs/setup/production-environment/container-runtimes/">CRI 安装</a>。</p><h4 id="containerd"><a href="#containerd" class="headerlink" title="containerd"></a><a href="https://containerd.io/docs/">containerd</a><a href="#hahahugoshortcodes3hbhb"></a></h4><p>通过 containerd 的 <code>/etc/containerd/config.toml</code> 配置文件来配置运行时 handler。 handler 需要配置在 runtimes 块中：</p><pre class="line-numbers language-none"><code class="language-none">[plugins."io.containerd.grpc.v1.cri".containerd.runtimes.${HANDLER_NAME}]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>更详细信息，请查阅 containerd 的<a href="https://github.com/containerd/containerd/blob/main/docs/cri/config.md">配置指南</a></p><h4 id="CRI-O"><a href="#CRI-O" class="headerlink" title="CRI-O"></a><a href="https://cri-o.io/#what-is-cri-o">CRI-O</a><a href="#hahahugoshortcodes4hbhb"></a></h4><p>通过 CRI-O 的 <code>/etc/crio/crio.conf</code> 配置文件来配置运行时 handler。 handler 需要配置在 <a href="https://github.com/cri-o/cri-o/blob/master/docs/crio.conf.5.md#crioruntime-table">crio.runtime 表</a>之下：</p><pre class="line-numbers language-none"><code class="language-none">[crio.runtime.runtimes.${HANDLER_NAME}]  runtime_path = "${PATH_TO_BINARY}"<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>更详细信息，请查阅 CRI-O <a href="https://github.com/cri-o/cri-o/blob/master/docs/crio.conf.5.md">配置文档</a>。</p><h2 id="调度"><a href="#调度" class="headerlink" title="调度"></a>调度<a href="#scheduling"></a></h2><p><strong>特性状态：</strong> <code>Kubernetes v1.16 [beta]</code></p><p>通过为 RuntimeClass 指定 <code>scheduling</code> 字段， 你可以通过设置约束，确保运行该 RuntimeClass 的 Pod 被调度到支持该 RuntimeClass 的节点上。 如果未设置 <code>scheduling</code>，则假定所有节点均支持此 RuntimeClass。</p><p>为了确保 pod 会被调度到支持指定运行时的 node 上，每个 node 需要设置一个通用的 label 用于被 <code>runtimeclass.scheduling.nodeSelector</code> 挑选。在 admission 阶段，RuntimeClass 的 nodeSelector 将会与 Pod 的 nodeSelector 合并，取二者的交集。如果有冲突，Pod 将会被拒绝。</p><p>如果 node 需要阻止某些需要特定 RuntimeClass 的 Pod，可以在 <code>tolerations</code> 中指定。 与 <code>nodeSelector</code> 一样，tolerations 也在 admission 阶段与 Pod 的 tolerations 合并，取二者的并集。</p><p>更多有关 node selector 和 tolerations 的配置信息，请查阅 <a href="https://kubernetes.io/zh-cn/docs/concepts/scheduling-eviction/assign-pod-node/">将 Pod 分派到节点</a>。</p><h3 id="Pod-开销"><a href="#Pod-开销" class="headerlink" title="Pod 开销"></a>Pod 开销<a href="#pod-overhead"></a></h3><p><strong>特性状态：</strong> <code>Kubernetes v1.24 [stable]</code></p><p>你可以指定与运行 Pod 相关的<strong>开销</strong>资源。声明开销即允许集群（包括调度器）在决策 Pod 和资源时将其考虑在内。</p><p>Pod 开销通过 RuntimeClass 的 <code>overhead</code> 字段定义。 通过使用这个字段，你可以指定使用该 RuntimeClass 运行 Pod 时的开销并确保 Kubernetes 将这些开销计算在内。</p><h2 id="接下来"><a href="#接下来" class="headerlink" title="接下来"></a>接下来<a href="#%E6%8E%A5%E4%B8%8B%E6%9D%A5"></a></h2><ul><li><a href="https://github.com/kubernetes/enhancements/blob/master/keps/sig-node/585-runtime-class/README.md">RuntimeClass 设计</a></li><li><a href="https://github.com/kubernetes/enhancements/blob/master/keps/sig-node/585-runtime-class/README.md#runtimeclass-scheduling">RuntimeClass 调度设计</a></li><li>阅读关于 <a href="https://kubernetes.io/zh-cn/docs/concepts/scheduling-eviction/pod-overhead/">Pod 开销</a>的概念</li><li><a href="https://github.com/kubernetes/enhancements/tree/master/keps/sig-node/688-pod-overhead">PodOverhead 特性设计</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> kubernetes </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>镜像 - Kubernetes 镜像 - Kubernetes</title>
      <link href="/2023/10/03/jing-xiang-kubernetes-jing-xiang-kubernetes/"/>
      <url>/2023/10/03/jing-xiang-kubernetes-jing-xiang-kubernetes/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本文由 <a href="http://ksria.com/simpread/">简悦 SimpRead</a> 转码， 原文地址 <a href="https://kubernetes.io/zh-cn/docs/concepts/containers/images/#imagepullpolicy-defaulting">kubernetes.io</a></p></blockquote><blockquote><p>容器镜像（Image）所承载的是封装了应用程序及其所有软件依赖的二进制数据。</p></blockquote><p>容器镜像（Image）所承载的是封装了应用程序及其所有软件依赖的二进制数据。 容器镜像是可执行的软件包，可以单独运行；该软件包对所处的运行时环境具有良定（Well Defined）的假定。</p><p>你通常会创建应用的容器镜像并将其推送到某仓库（Registry），然后在 <a href="https://kubernetes.io/zh-cn/docs/concepts/workloads/pods/">Pod</a> 中引用它。</p><p>本页概要介绍容器镜像的概念。</p><p><strong>说明：</strong></p><p>如果你正在寻找 Kubernetes 某个发行版本（如最新次要版本 v1.27） 的容器镜像，请访问<a href="https://kubernetes.io/zh-cn/releases/download/">下载 Kubernetes</a>。</p><h2 id="镜像名称"><a href="#镜像名称" class="headerlink" title="镜像名称"></a>镜像名称<a href="#image-names"></a></h2><p>容器镜像通常会被赋予 <code>pause</code>、<code>example/mycontainer</code> 或者 <code>kube-apiserver</code> 这类的名称。 镜像名称也可以包含所在仓库的主机名。例如：<code>fictional.registry.example/imagename</code>。 还可以包含仓库的端口号，例如：<code>fictional.registry.example:10443/imagename</code>。</p><p>如果你不指定仓库的主机名，Kubernetes 认为你在使用 Docker 公共仓库。</p><p>在镜像名称之后，你可以添加一个<strong>标签（Tag）</strong>（与使用 <code>docker</code> 或 <code>podman</code> 等命令时的方式相同）。 使用标签能让你辨识同一镜像序列中的不同版本。</p><p>镜像标签可以包含小写字母、大写字母、数字、下划线（<code>_</code>）、句点（<code>.</code>）和连字符（<code>-</code>）。 关于在镜像标签中何处可以使用分隔字符（<code>_</code>、<code>-</code> 和 <code>.</code>）还有一些额外的规则。 如果你不指定标签，Kubernetes 认为你想使用标签 <code>latest</code>。</p><h2 id="更新镜像"><a href="#更新镜像" class="headerlink" title="更新镜像"></a>更新镜像<a href="#updating-images"></a></h2><p>当你最初创建一个 <a href="https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/deployment/">Deployment</a>、 <a href="https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/statefulset/">StatefulSet</a>、Pod 或者其他包含 Pod 模板的对象时，如果没有显式设定的话， Pod 中所有容器的默认镜像拉取策略是 <code>IfNotPresent</code>。这一策略会使得 <a href="https://kubernetes.io/docs/reference/generated/kubelet">kubelet</a> 在镜像已经存在的情况下直接略过拉取镜像的操作。</p><h3 id="镜像拉取策略"><a href="#镜像拉取策略" class="headerlink" title="镜像拉取策略"></a>镜像拉取策略<a href="#image-pull-policy"></a></h3><p>容器的 <code>imagePullPolicy</code> 和镜像的标签会影响 <a href="https://kubernetes.io/zh-cn/docs/reference/command-line-tools-reference/kubelet/">kubelet</a> 尝试拉取（下载）指定的镜像。</p><p>以下列表包含了 <code>imagePullPolicy</code> 可以设置的值，以及这些值的效果：</p><p><code>IfNotPresent</code></p><p>只有当镜像在本地不存在时才会拉取。</p><p><code>Always</code></p><p>每当 kubelet 启动一个容器时，kubelet 会查询容器的镜像仓库， 将名称解析为一个镜像<a href="https://docs.docker.com/engine/reference/commandline/pull/#pull-an-image-by-digest-immutable-identifier">摘要</a>。 如果 kubelet 有一个容器镜像，并且对应的摘要已在本地缓存，kubelet 就会使用其缓存的镜像； 否则，kubelet 就会使用解析后的摘要拉取镜像，并使用该镜像来启动容器。</p><p><code>Never</code></p><p>Kubelet 不会尝试获取镜像。如果镜像已经以某种方式存在本地， kubelet 会尝试启动容器；否则，会启动失败。 更多细节见<a href="#pre-pulled-images">提前拉取镜像</a>。</p><p>只要能够可靠地访问镜像仓库，底层镜像提供者的缓存语义甚至可以使 <code>imagePullPolicy: Always</code> 高效。 你的容器运行时可以注意到节点上已经存在的镜像层，这样就不需要再次下载。</p><p><strong>说明：</strong></p><p>在生产环境中部署容器时，你应该避免使用 <code>:latest</code> 标签，因为这使得正在运行的镜像的版本难以追踪，并且难以正确地回滚。</p><p>相反，应指定一个有意义的标签，如 <code>v1.42.0</code>，和 / 或者一个摘要。</p><p>为了确保 Pod 总是使用相同版本的容器镜像，你可以指定镜像的摘要； 将 <code>&lt;image-name&gt;:&lt;tag&gt;</code> 替换为 <code>&lt;image-name&gt;@&lt;digest&gt;</code>，例如 <code>image@sha256:45b23dee08af5e43a7fea6c4cf9c25ccf269ee113168c19722f87876677c5cb2</code>。</p><p>当使用镜像标签时，如果镜像仓库修改了代码所对应的镜像标签，可能会出现新旧代码混杂在 Pod 中运行的情况。 镜像摘要唯一标识了镜像的特定版本，因此 Kubernetes 每次启动具有指定镜像名称和摘要的容器时，都会运行相同的代码。 通过摘要指定镜像可固定你运行的代码，这样镜像仓库的变化就不会导致版本的混杂。</p><p>有一些第三方的<a href="https://kubernetes.io/zh-cn/docs/reference/access-authn-authz/admission-controllers/">准入控制器</a> 在创建 Pod（和 Pod 模板）时产生变更，这样运行的工作负载就是根据镜像摘要，而不是标签来定义的。 无论镜像仓库上的标签发生什么变化，你都想确保你所有的工作负载都运行相同的代码，那么指定镜像摘要会很有用。</p><h4 id="默认镜像拉取策略"><a href="#默认镜像拉取策略" class="headerlink" title="默认镜像拉取策略"></a>默认镜像拉取策略<a href="#imagepullpolicy-defaulting"></a></h4><p>当你（或控制器）向 API 服务器提交一个新的 Pod 时，你的集群会在满足特定条件时设置 <code>imagePullPolicy</code> 字段：</p><ul><li><p>如果你省略了 <code>imagePullPolicy</code> 字段，并且你为容器镜像指定了摘要， 那么 <code>imagePullPolicy</code> 会自动设置为 <code>IfNotPresent</code>。</p></li><li><p>如果你省略了 <code>imagePullPolicy</code> 字段，并且容器镜像的标签是 <code>:latest</code>， <code>imagePullPolicy</code> 会自动设置为 <code>Always</code>。</p></li><li><p>如果你省略了 <code>imagePullPolicy</code> 字段，并且没有指定容器镜像的标签， <code>imagePullPolicy</code> 会自动设置为 <code>Always</code>。</p></li><li><p>如果你省略了 <code>imagePullPolicy</code> 字段，并且为容器镜像指定了非 <code>:latest</code> 的标签， <code>imagePullPolicy</code> 就会自动设置为 <code>IfNotPresent</code>。</p></li></ul><p><strong>说明：</strong></p><p>容器的 <code>imagePullPolicy</code> 的值总是在对象初次 <em>创建</em> 时设置的， 如果后来镜像的标签或摘要发生变化，则不会更新。</p><p>例如，如果你用一个 <strong>非</strong> <code>:latest</code> 的镜像标签创建一个 Deployment， 并在随后更新该 Deployment 的镜像标签为 <code>:latest</code>，则 <code>imagePullPolicy</code> 字段 <strong>不会</strong> 变成 <code>Always</code>。 你必须手动更改已经创建的资源的拉取策略。</p><h4 id="必要的镜像拉取"><a href="#必要的镜像拉取" class="headerlink" title="必要的镜像拉取"></a>必要的镜像拉取<a href="#required-image-pull"></a></h4><p>如果你想总是强制执行拉取，你可以使用下述的一中方式：</p><ul><li>设置容器的 <code>imagePullPolicy</code> 为 <code>Always</code>。</li><li>省略 <code>imagePullPolicy</code>，并使用 <code>:latest</code> 作为镜像标签； 当你提交 Pod 时，Kubernetes 会将策略设置为 <code>Always</code>。</li><li>省略 <code>imagePullPolicy</code> 和镜像的标签； 当你提交 Pod 时，Kubernetes 会将策略设置为 <code>Always</code>。</li><li>启用准入控制器 <a href="https://kubernetes.io/zh-cn/docs/reference/access-authn-authz/admission-controllers/#alwayspullimages">AlwaysPullImages</a>。</li></ul><h3 id="ImagePullBackOff"><a href="#ImagePullBackOff" class="headerlink" title="ImagePullBackOff"></a>ImagePullBackOff<a href="#imagepullbackoff"></a></h3><p>当 kubelet 使用容器运行时创建 Pod 时，容器可能因为 <code>ImagePullBackOff</code> 导致状态为 <a href="https://kubernetes.io/zh-cn/docs/concepts/workloads/pods/pod-lifecycle/#container-state-waiting">Waiting</a>。</p><p><code>ImagePullBackOff</code> 状态意味着容器无法启动， 因为 Kubernetes 无法拉取容器镜像（原因包括无效的镜像名称，或从私有仓库拉取而没有 <code>imagePullSecret</code>）。 <code>BackOff</code> 部分表示 Kubernetes 将继续尝试拉取镜像，并增加回退延迟。</p><p>Kubernetes 会增加每次尝试之间的延迟，直到达到编译限制，即 300 秒（5 分钟）。</p><h2 id="串行和并行镜像拉取"><a href="#串行和并行镜像拉取" class="headerlink" title="串行和并行镜像拉取"></a>串行和并行镜像拉取<a href="#serial-and-parallel-image-pulls"></a></h2><p>默认情况下，kubelet 以串行方式拉取镜像。 也就是说，kubelet 一次只向镜像服务发送一个镜像拉取请求。 其他镜像拉取请求必须等待，直到正在处理的那个请求完成。</p><p>节点独立地做出镜像拉取的决策。即使你使用串行的镜像拉取，两个不同的节点也可以并行拉取相同的镜像。</p><p>如果你想启用并行镜像拉取，可以在 <a href="https://kubernetes.io/zh-cn/docs/reference/config-api/kubelet-config.v1beta1/">kubelet 配置</a> 中将字段 <code>serializeImagePulls</code> 设置为 false。</p><p>当<code>serializeImagePulls</code> 设置为 false 时，kubelet 会立即向镜像服务发送镜像拉取请求，多个镜像将同时被拉动。</p><p>启用并行镜像拉取时，请确保你的容器运行时的镜像服务可以处理并行镜像拉取。</p><p>kubelet 从不代表一个 Pod 并行地拉取多个镜像。</p><p>例如，如果你有一个 Pod，它有一个初始容器和一个应用容器，那么这两个容器的镜像拉取将不会并行。 但是，如果你有两个使用不同镜像的 Pod，当启用并行镜像拉取时，kubelet 会代表两个不同的 Pod 并行拉取镜像。</p><h3 id="最大并行镜像拉取数量"><a href="#最大并行镜像拉取数量" class="headerlink" title="最大并行镜像拉取数量"></a>最大并行镜像拉取数量<a href="#maximum-parallel-image-pulls"></a></h3><p><strong>特性状态：</strong> <code>Kubernetes v1.27 [alpha]</code></p><p>当 <code>serializeImagePulls</code> 被设置为 false 时，kubelet 默认对同时拉取的最大镜像数量没有限制。 如果你想限制并行镜像拉取的数量，可以在 kubelet 配置中设置字段 <code>maxParallelImagePulls</code>。 当 <code>maxParallelImagePulls</code> 设置为 <em>n</em> 时，只能同时拉取 <em>n</em> 个镜像， 超过 <em>n</em> 的任何镜像都必须等到至少一个正在进行拉取的镜像拉取完成后，才能拉取。</p><p>当启用并行镜像拉取时，限制并行镜像拉取的数量可以防止镜像拉取消耗过多的网络带宽或磁盘 I/O。</p><p>你可以将 <code>maxParallelImagePulls</code> 设置为大于或等于 1 的正数。 如果将 <code>maxParallelImagePulls</code> 设置为大于等于 2，则必须将 <code>serializeImagePulls</code> 设置为 false。 kubelet 在无效的 <code>maxParallelImagePulls</code> 设置下会启动失败。</p><h2 id="带镜像索引的多架构镜像"><a href="#带镜像索引的多架构镜像" class="headerlink" title="带镜像索引的多架构镜像"></a>带镜像索引的多架构镜像<a href="#multi-architecture-images-with-image-indexes"></a></h2><p>除了提供二进制的镜像之外， 容器仓库也可以提供<a href="https://github.com/opencontainers/image-spec/blob/master/image-index.md">容器镜像索引</a>。 镜像索引可以指向镜像的多个<a href="https://github.com/opencontainers/image-spec/blob/master/manifest.md">镜像清单</a>， 提供特定于体系结构版本的容器。 这背后的理念是让你可以为镜像命名（例如：<code>pause</code>、<code>example/mycontainer</code>、<code>kube-apiserver</code>） 的同时，允许不同的系统基于它们所使用的机器体系结构取回正确的二进制镜像。</p><p>Kubernetes 自身通常在命名容器镜像时添加后缀 <code>-$(ARCH)</code>。 为了向前兼容，请在生成较老的镜像时也提供后缀。 这里的理念是为某镜像（如 <code>pause</code>）生成针对所有平台都适用的清单时， 生成 <code>pause-amd64</code> 这类镜像，以便较老的配置文件或者将镜像后缀硬编码到其中的 YAML 文件也能兼容。</p><h2 id="使用私有仓库"><a href="#使用私有仓库" class="headerlink" title="使用私有仓库"></a>使用私有仓库<a href="#using-a-private-registry"></a></h2><p>从私有仓库读取镜像时可能需要密钥。 凭据可以用以下方式提供:</p><ul><li>配置节点向私有仓库进行身份验证<ul><li>所有 Pod 均可读取任何已配置的私有仓库</li><li>需要集群管理员配置节点</li></ul></li><li>kubelet 凭据提供程序，动态获取私有仓库的凭据<ul><li>kubelet 可以被配置为使用凭据提供程序 exec 插件来访问对应的私有镜像库</li></ul></li><li>预拉镜像<ul><li>所有 Pod 都可以使用节点上缓存的所有镜像</li><li>需要所有节点的 root 访问权限才能进行设置</li></ul></li><li>在 Pod 中设置 ImagePullSecrets<ul><li>只有提供自己密钥的 Pod 才能访问私有仓库</li></ul></li><li>特定于厂商的扩展或者本地扩展<ul><li>如果你在使用定制的节点配置，你（或者云平台提供商）可以实现让节点向容器仓库认证的机制</li></ul></li></ul><p>下面将详细描述每一项。</p><h3 id="配置-Node-对私有仓库认证"><a href="#配置-Node-对私有仓库认证" class="headerlink" title="配置 Node 对私有仓库认证"></a>配置 Node 对私有仓库认证<a href="#configuring-nodes-to-authenticate-to-a-private-registry"></a></h3><p>设置凭据的具体说明取决于你选择使用的容器运行时和仓库。 你应该参考解决方案的文档来获取最准确的信息。</p><p>有关配置私有容器镜像仓库的示例， 请参阅任务<a href="https://kubernetes.io/zh-cn/docs/tasks/configure-pod-container/pull-image-private-registry">从私有镜像库中拉取镜像</a>。 该示例使用 Docker Hub 中的私有镜像仓库。</p><h3 id="用于认证镜像拉取的-kubelet-凭据提供程序"><a href="#用于认证镜像拉取的-kubelet-凭据提供程序" class="headerlink" title="用于认证镜像拉取的 kubelet 凭据提供程序"></a>用于认证镜像拉取的 kubelet 凭据提供程序<a href="#kubelet-credential-provider"></a></h3><p><strong>说明：</strong></p><p>此方法尤其适合 kubelet 需要动态获取仓库凭据时。 最常用于由云提供商提供的仓库，其中身份认证令牌的生命期是短暂的。</p><p>你可以配置 kubelet，以调用插件可执行文件的方式来动态获取容器镜像的仓库凭据。 这是为私有仓库获取凭据最稳健和最通用的方法，但也需要 kubelet 级别的配置才能启用。</p><p>有关更多细节请参见<a href="https://kubernetes.io/docs/tasks/administer-cluster/kubelet-credential-provider/">配置 kubelet 镜像凭据提供程序</a>。</p><h3 id="config-json-说明"><a href="#config-json-说明" class="headerlink" title="config.json 说明"></a>config.json 说明<a href="#config-json"></a></h3><p>对于 <code>config.json</code> 的解释在原始 Docker 实现和 Kubernetes 的解释之间有所不同。 在 Docker 中，<code>auths</code> 键只能指定根 URL，而 Kubernetes 允许 glob URLs 以及前缀匹配的路径。 这意味着，像这样的 <code>config.json</code> 是有效的：</p><pre class="line-numbers language-none"><code class="language-none">{    "auths": {        "*my-registry.io/images": {            "auth": "…"        }    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>使用以下语法匹配根 URL （<code>*my-registry.io</code>）：</p><pre class="line-numbers language-none"><code class="language-none">pattern:    { term }term:    '*'         匹配任何无分隔符字符序列    '?'         匹配任意单个非分隔符    '[' [ '^' ] 字符范围                  字符集（必须非空）    c           匹配字符 c （c 不为 '*', '?', '\\', '['）    '\\' c      匹配字符 c字符范围:    c           匹配字符 c （c 不为 '\\', '?', '-', ']'）    '\\' c      匹配字符 c    lo '-' hi   匹配字符范围在 lo 到 hi 之间字符<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>现在镜像拉取操作会将每种有效模式的凭据都传递给 CRI 容器运行时。例如下面的容器镜像名称会匹配成功：</p><ul><li><code>my-registry.io/images</code></li><li><code>my-registry.io/images/my-image</code></li><li><code>my-registry.io/images/another-image</code></li><li><code>sub.my-registry.io/images/my-image</code></li><li><code>a.sub.my-registry.io/images/my-image</code></li></ul><p>kubelet 为每个找到的凭据的镜像按顺序拉取。这意味着在 <code>config.json</code> 中可能有多项：</p><pre class="line-numbers language-none"><code class="language-none">{    "auths": {        "my-registry.io/images": {            "auth": "…"        },        "my-registry.io/images/subpath": {            "auth": "…"        }    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果一个容器指定了要拉取的镜像 <code>my-registry.io/images/subpath/my-image</code>， 并且其中一个失败，kubelet 将尝试从另一个身份验证源下载镜像。</p><h3 id="提前拉取镜像"><a href="#提前拉取镜像" class="headerlink" title="提前拉取镜像"></a>提前拉取镜像<a href="#pre-pulled-images"></a></h3><p><strong>说明：</strong></p><p>该方法适用于你能够控制节点配置的场合。 如果你的云供应商负责管理节点并自动置换节点，这一方案无法可靠地工作。</p><p>默认情况下，<code>kubelet</code> 会尝试从指定的仓库拉取每个镜像。 但是，如果容器属性 <code>imagePullPolicy</code> 设置为 <code>IfNotPresent</code> 或者 <code>Never</code>， 则会优先使用（对应 <code>IfNotPresent</code>）或者一定使用（对应 <code>Never</code>）本地镜像。</p><p>如果你希望使用提前拉取镜像的方法代替仓库认证，就必须保证集群中所有节点提前拉取的镜像是相同的。</p><p>这一方案可以用来提前载入指定的镜像以提高速度，或者作为向私有仓库执行身份认证的一种替代方案。</p><p>所有的 Pod 都可以使用节点上提前拉取的镜像。</p><h3 id="在-Pod-上指定-ImagePullSecrets"><a href="#在-Pod-上指定-ImagePullSecrets" class="headerlink" title="在 Pod 上指定 ImagePullSecrets"></a>在 Pod 上指定 ImagePullSecrets<a href="#specifying-imagepullsecrets-on-a-pod"></a></h3><p><strong>说明：</strong></p><p>运行使用私有仓库中镜像的容器时，建议使用这种方法。</p><p>Kubernetes 支持在 Pod 中设置容器镜像仓库的密钥。 <code>imagePullSecrets</code> 必须全部与 Pod 位于同一个名字空间中。 引用的 Secret 必须是 <code>kubernetes.io/dockercfg</code> 或 <code>kubernetes.io/dockerconfigjson</code> 类型。</p><h4 id="使用-Docker-Config-创建-Secret"><a href="#使用-Docker-Config-创建-Secret" class="headerlink" title="使用 Docker Config 创建 Secret"></a>使用 Docker Config 创建 Secret<a href="#creating-a-secret-with-docker-config"></a></h4><p>你需要知道用于向仓库进行身份验证的用户名、密码和客户端电子邮件地址，以及它的主机名。 运行以下命令，注意替换适当的大写值：</p><pre class="line-numbers language-none"><code class="language-none">kubectl create secret docker-registry &lt;name&gt; \  --docker-server=DOCKER_REGISTRY_SERVER \  --docker-username=DOCKER_USER \  --docker-password=DOCKER_PASSWORD \  --docker-email=DOCKER_EMAIL<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果你已经有 Docker 凭据文件，则可以将凭据文件导入为 Kubernetes <a href="https://kubernetes.io/zh-cn/docs/concepts/configuration/secret/">Secret</a>， 而不是执行上面的命令。 <a href="https://kubernetes.io/zh-cn/docs/tasks/configure-pod-container/pull-image-private-registry/#registry-secret-existing-credentials">基于已有的 Docker 凭据创建 Secret</a> 解释了如何完成这一操作。</p><p>如果你在使用多个私有容器仓库，这种技术将特别有用。 原因是 <code>kubectl create secret docker-registry</code> 创建的是仅适用于某个私有仓库的 Secret。</p><p><strong>说明：</strong></p><p>Pod 只能引用位于自身所在名字空间中的 Secret，因此需要针对每个名字空间重复执行上述过程。</p><h4 id="在-Pod-中引用-ImagePullSecrets"><a href="#在-Pod-中引用-ImagePullSecrets" class="headerlink" title="在 Pod 中引用 ImagePullSecrets"></a>在 Pod 中引用 ImagePullSecrets<a href="#referring-to-an-imagepullsecrets-on-a-pod"></a></h4><p>现在，在创建 Pod 时，可以在 Pod 定义中增加 <code>imagePullSecrets</code> 部分来引用该 Secret。 <code>imagePullSecrets</code> 数组中的每一项只能引用同一名字空间中的 Secret。</p><p>例如：</p><pre class="line-numbers language-none"><code class="language-none">cat &lt;&lt;EOF &gt; pod.yamlapiVersion: v1kind: Podmetadata:  name: foo  namespace: awesomeappsspec:  containers:    - name: foo      image: janedoe/awesomeapp:v1  imagePullSecrets:    - name: myregistrykeyEOFcat &lt;&lt;EOF &gt;&gt; ./kustomization.yamlresources:- pod.yamlEOF<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>你需要对使用私有仓库的每个 Pod 执行以上操作。不过， 设置该字段的过程也可以通过为<a href="https://kubernetes.io/zh-cn/docs/tasks/configure-pod-container/configure-service-account/">服务账号</a>资源设置 <code>imagePullSecrets</code> 来自动完成。 有关详细指令， 可参见<a href="https://kubernetes.io/zh-cn/docs/tasks/configure-pod-container/configure-service-account/#add-imagepullsecrets-to-a-service-account">将 ImagePullSecrets 添加到服务账号</a>。</p><p>你也可以将此方法与节点级别的 <code>.docker/config.json</code> 配置结合使用。 来自不同来源的凭据会被合并。</p><h2 id="使用案例"><a href="#使用案例" class="headerlink" title="使用案例"></a>使用案例<a href="#use-cases"></a></h2><p>配置私有仓库有多种方案，以下是一些常用场景和建议的解决方案。</p><ol><li><p>集群运行非专有镜像（例如，开源镜像）。镜像不需要隐藏。</p><ul><li>使用来自公共仓库的公共镜像<ul><li>无需配置</li><li>某些云厂商会自动为公开镜像提供高速缓存，以便提升可用性并缩短拉取镜像所需时间</li></ul></li></ul></li><li><p>集群运行一些专有镜像，这些镜像需要对公司外部隐藏，对所有集群用户可见</p><ul><li>使用托管的私有仓库<ul><li>在需要访问私有仓库的节点上可能需要手动配置</li></ul></li><li>或者，在防火墙内运行一个组织内部的私有仓库，并开放读取权限<ul><li>不需要配置 Kubernetes</li></ul></li><li>使用控制镜像访问的托管容器镜像仓库服务<ul><li>与手动配置节点相比，这种方案能更好地处理集群自动扩缩容</li></ul></li><li>或者，在不方便更改节点配置的集群中，使用 <code>imagePullSecrets</code></li></ul></li><li><p>集群使用专有镜像，且有些镜像需要更严格的访问控制</p><ul><li>确保 <a href="https://kubernetes.io/zh-cn/docs/reference/access-authn-authz/admission-controllers/#alwayspullimages">AlwaysPullImages 准入控制器</a>被启用。否则，所有 Pod 都可以使用所有镜像。</li><li>确保将敏感数据存储在 Secret 资源中，而不是将其打包在镜像里</li></ul></li><li><p>集群是多租户的并且每个租户需要自己的私有仓库</p><ul><li>确保 <a href="https://kubernetes.io/zh-cn/docs/reference/access-authn-authz/admission-controllers/#alwayspullimages">AlwaysPullImages 准入控制器</a>。否则，所有租户的所有的 Pod 都可以使用所有镜像。</li><li>为私有仓库启用鉴权</li><li>为每个租户生成访问仓库的凭据，放置在 Secret 中，并将 Secret 发布到各租户的名字空间下。</li><li>租户将 Secret 添加到每个名字空间中的 imagePullSecrets</li></ul></li></ol><p>如果你需要访问多个仓库，可以为每个仓库创建一个 Secret。</p><h2 id="旧版的内置-kubelet-凭据提供程序"><a href="#旧版的内置-kubelet-凭据提供程序" class="headerlink" title="旧版的内置 kubelet 凭据提供程序"></a>旧版的内置 kubelet 凭据提供程序<a href="#%E6%97%A7%E7%89%88%E7%9A%84%E5%86%85%E7%BD%AE-kubelet-%E5%87%AD%E6%8D%AE%E6%8F%90%E4%BE%9B%E7%A8%8B%E5%BA%8F"></a></h2><p>在旧版本的 Kubernetes 中，kubelet 与云提供商凭据直接集成。 这使它能够动态获取镜像仓库的凭据。</p><p>kubelet 凭据提供程序集成存在三个内置实现： ACR（Azure 容器仓库）、ECR（Elastic 容器仓库）和 GCR（Google 容器仓库）</p><p>有关该旧版机制的更多信息，请阅读你正在使用的 Kubernetes 版本的文档。 从 Kubernetes v1.26 到 v1.27 不再包含该旧版机制，因此你需要：</p><ul><li>在每个节点上配置一个 kubelet 镜像凭据提供程序</li><li>使用 <code>imagePullSecrets</code> 和至少一个 Secret 指定镜像拉取凭据</li></ul><h2 id="接下来"><a href="#接下来" class="headerlink" title="接下来"></a>接下来<a href="#%E6%8E%A5%E4%B8%8B%E6%9D%A5"></a></h2><ul><li>阅读 <a href="https://github.com/opencontainers/image-spec/blob/master/manifest.md">OCI Image Manifest 规范</a>。</li><li>了解<a href="https://kubernetes.io/zh-cn/docs/concepts/architecture/garbage-collection/#container-image-garbage-collection">容器镜像垃圾收集</a>。</li><li>了解<a href="https://kubernetes.io/zh-cn/docs/tasks/configure-pod-container/pull-image-private-registry">从私有仓库拉取镜像</a>。</li></ul>]]></content>
      
      
      <categories>
          
          <category> kubernetes </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>在 nfs 服务器创建共享目录，部署的 gitlib 使用共享目录来进行持久化</title>
      <link href="/2023/10/03/k8s-bu-shu-gitlab-deployment-ji-yu-nfs-jin-xing-shu-ju-chi-jiu-hua-xue-liang-bian-cheng-shou-ji-de-bo-ke-csdn-bo-ke/"/>
      <url>/2023/10/03/k8s-bu-shu-gitlab-deployment-ji-yu-nfs-jin-xing-shu-ju-chi-jiu-hua-xue-liang-bian-cheng-shou-ji-de-bo-ke-csdn-bo-ke/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本文由 <a href="http://ksria.com/simpread/">简悦 SimpRead</a> 转码， 原文地址 <a href="https://blog.csdn.net/a772304419/article/details/126622063">blog.csdn.net</a></p></blockquote><h1 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h1><h2 id="1-1-创建-nfs-共享目录"><a href="#1-1-创建-nfs-共享目录" class="headerlink" title="1.1 创建 nfs 共享目录"></a>1.1 创建 <a href="https://so.csdn.net/so/search?q=nfs&amp;spm=1001.2101.3001.7020">nfs</a> 共享目录</h2><p>在 nfs 服务器创建共享目录，部署的 gitlib 使用共享目录来进行持久化，这样不管在哪个节点运行 gitlib 都没有关系。</p><pre class="line-numbers language-none"><code class="language-none"># mkdir -p /home/k8s-nfs/gitlab/config# mkdir -p /home/k8s-nfs/gitlab/logs# mkdir -p /home/k8s-nfs/gitlab/data<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="1-2-添加到共享"><a href="#1-2-添加到共享" class="headerlink" title="1.2 添加到共享"></a>1.2 添加到共享</h2><pre class="line-numbers language-none"><code class="language-none">vim /etc/exports/home/k8s-nfs/gitlab/config 192.168.17.0/8(rw,no_root_squash)/home/k8s-nfs/gitlab/logs 192.168.17.0/8(rw,no_root_squash)/home/k8s-nfs/gitlab/data 192.168.17.0/8(rw,no_root_squash)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="1-3-执行更新"><a href="#1-3-执行更新" class="headerlink" title="1.3 执行更新"></a>1.3 执行更新</h2><pre class="line-numbers language-none"><code class="language-none"># service nfs restart或者# exportfs -r<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><script async="" src="//www.imageoss.com/sdk/pup.js" data-url="https://www.imageoss.com/upload"></script><h1 id="部署-gitlib"><a href="#部署-gitlib" class="headerlink" title="部署 gitlib"></a>部署 gitlib</h1><h2 id="2-1-准备部署文件（gitlib-deploy-yaml）"><a href="#2-1-准备部署文件（gitlib-deploy-yaml）" class="headerlink" title="2.1 准备部署文件（gitlib-deploy.yaml）"></a>2.1 准备部署文件（gitlib-deploy.yaml）</h2><pre class="line-numbers language-none"><code class="language-none">apiVersion: v1kind: Servicemetadata:  name: gitlabspec:  type: NodePort  ports:  # Port上的映射端口  - port: 443    targetPort: 443    name: gitlab443  - port: 80    targetPort: 80    name: gitlab80  - port: 22    targetPort: 22    name: gitlab22  selector:    app: gitlab --- apiVersion: apps/v1kind: Deploymentmetadata:  name: gitlabspec:  selector:    matchLabels:      app: gitlab  revisionHistoryLimit: 2  template:    metadata:      labels:        app: gitlab    spec:      containers:      # 应用的镜像      - image: gitlab/gitlab-ce         name: gitlab        imagePullPolicy: IfNotPresent        # 应用的内部端口        ports:        - containerPort: 443          name: gitlab443        - containerPort: 80          name: gitlab80        - containerPort: 22          name: gitlab22        volumeMounts:        # gitlab持久化        - name: gitlab-persistent-config          mountPath: /etc/gitlab        - name: gitlab-persistent-logs          mountPath: /var/log/gitlab        - name: gitlab-persistent-data          mountPath: /var/opt/gitlab      imagePullSecrets:      - name: devops-repo      volumes:      # 使用nfs互联网存储      - name: gitlab-persistent-config        nfs:          server: 192.168.17.81          path: /home/k8s-nfs/gitlab/config      - name: gitlab-persistent-logs        nfs:          server: 192.168.17.81          path: /home/k8s-nfs/gitlab/logs      - name: gitlab-persistent-data        nfs:          server: 192.168.17.81          path: /home/k8s-nfs/gitlab/data<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="2-2-执行部署"><a href="#2-2-执行部署" class="headerlink" title="2.2 执行部署"></a>2.2 执行部署</h2><pre class="line-numbers language-none"><code class="language-none"># kubectl apply -f gitlib-deploy.yaml<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="2-3-查看部署结果"><a href="#2-3-查看部署结果" class="headerlink" title="2.3 查看部署结果"></a>2.3 查看部署结果</h2><pre class="line-numbers language-none"><code class="language-none"># kubectl get deploy NAME     READY   UP-TO-DATE   AVAILABLE   AGEgitlab   1/1     1            1           134m<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>以上说明部署完成。</p><h1 id="gitlib-初始化"><a href="#gitlib-初始化" class="headerlink" title="gitlib 初始化"></a>gitlib 初始化</h1><h2 id="3-1-访问登录页面"><a href="#3-1-访问登录页面" class="headerlink" title="3.1 访问登录页面"></a>3.1 访问登录页面</h2><p>通过查看 service 映射的端口：</p><pre class="line-numbers language-none"><code class="language-none"># kubectl get svc -o wideNAME         TYPE        CLUSTER-IP      EXTERNAL-IP   PORT(S)                                   AGE    SELECTORgitlab       NodePort    10.10.129.28    &lt;none&gt;        443:31326/TCP,80:31320/TCP,22:31515/TCP   137m   app=gitlab<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到映射 80 端口的节点端口为：31320</p><p>通过指定端口访问登录页：</p><p><img src="https://img-blog.csdnimg.cn/62951a1a0eb344ce9d1cf0d8c7a941d1.png"></p><h2 id="3-2-初始用户名和密码"><a href="#3-2-初始用户名和密码" class="headerlink" title="3.2 初始用户名和密码"></a>3.2 初始用户名和密码</h2><p>初始用户名为 root，初始密码 gitlib 自动创建，在如下文件中：</p><pre class="line-numbers language-none"><code class="language-none">cat /etc/gitlab/initial_root_password<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>由于是容器部署，所以，需要进入到容器中，找到对应文件，拷贝密码进行登录。文件内容类似：</p><pre class="line-numbers language-none"><code class="language-none"># WARNING: This value is valid only in the following conditions# 1. If provided manually (either via `GITLAB_ROOT_PASSWORD` environment variable or via `gitlab_rails['initial_root_passwo# 2. Password hasn't been changed manually, either via UI or via command line.## If the password shown here doesn't work, you must reset the admin password following https://docs.gitlab.com/ee/security/Password: HCsr5VFAp28N*****************=# NOTE: This file will be automatically deleted in the first reconfigure run after 24 hours.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>参考链接：<a href="https://blog.csdn.net/m0_52544877/article/details/125448793">https://blog.csdn.net/m0_52544877/article/details/125448793</a></p>]]></content>
      
      
      <categories>
          
          <category> kubernetes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> kubernetes </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
